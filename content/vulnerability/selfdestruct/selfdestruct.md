---
emoji: 🧢
title: (취약점 시리즈 9) Self Destruct
date: '2022-01-09 17:29:00'
author: 한성원
tags: Self Destruct selfdestruct 취약점 SmartContract
categories: 취약점분석
---


# 👋 Self Destruct

## 들어가기전
### Self Destruct란 무엇인가?
1. self destruct는 contract를 삭제할 수 있는 유일한 수단이다.
2. contract안에 남아있는 Ether를 address에게 반환한다.

```solidity
selfdestruct(anAddress)
```

selfdestruct를 실행시키면 anAddress에게 contract에 남아있는 Ether이 반환된다. 만약에 반환하는 address는 EOA와 CA 모두 넣을 수 있다. 하지만 반환한 CA가 payable이 아니라면 반환된 Ether은 다시는 찾을 수 없게된다. 즉 반환된 CA에 영원히 __LOCK__ 된다.

보다 잘 이해하기 위해 Example Code를 살펴보자!!
- - -

## Example code
간단한 code로 이해해보자!
```solidity
contract EtherGame {
    uint public targetAmount = 7 ether;
    address public winner;

    function deposit() public payable {
        require(msg.value == 1 ether, "You can only send 1 Ether");

        uint balance = address(this).balance;
        require(balance <= targetAmount, "Game is over");

        if (balance == targetAmount) {
            winner = msg.sender;
        }
    }

    function claimReward() public {
        require(msg.sender == winner, "Not winner");

        (bool sent, ) = msg.sender.call{value: address(this).balance}("");
        require(sent, "Failed to send Ether");
    }
}

contract Attack {
    EtherGame etherGame;

    constructor(EtherGame _etherGame) {
        etherGame = EtherGame(_etherGame);
    }

    function attack() public payable {
        // You can simply break the game by sending ether so that
        // the game balance >= 7 ether

        // cast address to payable
        address payable addr = payable(address(etherGame));
        selfdestruct(addr);
    }
}
```
이 contract는 7번째로 deposit()하여 7 Ether를 가져갈 수 있는 게임이다.
deposit()을 call할 때 msg.value는 1 Ether만 설정할 수 있다.


시나리오는 이렇다.
1. EtherGame contract가 배포된다.
2. A와 B가 각각 1 Ether를 deposit() 한다.
3. 누군가 EtherGame contract의 주소와 함께 Attack contract를 배포한다.
4. 그리고 Attack.attack()을 call 한다.
5. EtherGame은 더 이상 실행될 수 없게되며 누구도 winner가 될 수 없게 된다.

EtherGame contract의 특성상 selfdestruct 공격에 취약할 수 밖에 없게 설계 되어있다. 


- - -

## How to prevent?
EtherGame contract에서 selfdestruct를 예방하기 위해서는 ```address(this).balance``` 대신 deposit()을 통해 들어온 balance를 따로 저장해주고 저장한 변수와 상호작용하면 된다. 위에 contract의 변수와 deposit()을 아래와 같이 바꾸면 된다!
```solidity 
contract EtherGame {
    uint public targetAmount = 3 ether;
    // 바뀐 부분!!!
    uint public balance;
    address public winner;

    function deposit() public payable {
        require(msg.value == 1 ether, "You can only send 1 Ether");

        //바뀐 부분!!!
        balance += msg.value;
        require(balance <= targetAmount, "Game is over");

        if (balance == targetAmount) {
            winner = msg.sender;
        }
    }
}
```

- - -

## 마무리
selfdestruct는 좀 흥미롭다. 블록체인 이외에서 들어본적도 없는 것이라 특별하다고 생각된다. 어떤 contract든 selfdestruct에 의해서 Ether를 받을 수 있다. 그렇기 때문에 ```address(this).balance```와 같은 contract의 balance를 사용해 balance를 불러오는 것을 자제하고 꼭 필요할때만 사용하자!!

- - -

### Reference
- https://swcregistry.io/docs/SWC-106
- https://solidity-by-example.org/hacks/self-destruct/

```toc

```