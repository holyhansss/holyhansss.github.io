{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/defi/OlympusDao에대하여/",
    "result": {"data":{"cur":{"id":"ac979ac3-92fb-532c-a651-d2167e935b53","html":"<h1 id=\"-olympus-dao에-대하여\" style=\"position:relative;\"><a href=\"#-olympus-dao%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC\" aria-label=\" olympus dao에 대하여 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>👋 Olympus Dao에 대하여</h1>\n<h2 id=\"olympus-dao란\" style=\"position:relative;\"><a href=\"#olympus-dao%EB%9E%80\" aria-label=\"olympus dao란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Olympus Dao란?</h2>\n<p>Olympus Dao는 중앙은행을 대채하기 위해 나온 탈중앙호 준비통화 프로토콜이다. 현재 Defi 2.0으로 현재는 시가총액이 많이 떨어졌지만 Defi 생태계를 이끌어가는 선두주자라고 할 수 있다.</p>\n<blockquote>\n<p>준비통화(Reserve Currency)란 준비 통화는 국가별로 지급을 대비해 보유한 외국환을 말한다.\r\nEx) 미국의 준비통화: 달러(Dollar), Olympus Dao의 준비통화: OHM</p>\n</blockquote>\n<p>Defi의 근본적인 목적을 달성하기 위해 Olympus Dao는 OHM이라는 준비통화를 사용한다. 달러의 경우 특정 집단(미 연준)이 통제권을 가지고 있다. 이에 반해서 Olympus Dao의 ohm은 커뮤니티가 통제권을 가지고 있다. 또한 커뮤니티가 앞으로의 방향성을 결정하며 투명하고 안정적인 준비통화 시스템을 만들어 나간다.</p>\n<h2 id=\"ohm의-특징-ohm-is-backed\" style=\"position:relative;\"><a href=\"#ohm%EC%9D%98-%ED%8A%B9%EC%A7%95-ohm-is-backed\" aria-label=\"ohm의 특징 ohm is backed permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OHM의 특징 (OHM Is Backed)</h2>\n<p>현재 대부분의 스테이블 코인들은 1달러에 pegged 되어있다. 즉 1 스테이블 코인 = 1달러 라는 뜻이다. 하지만 OHM은 1 달러에 pegged 되는 대신 1달러를 지지(backing)한다. 좀 풀어서 말하면 OHM의 상한선은 정해져 있지 않지만, 하한선은 1달러로 정해져 있다는 뜻이다. 만약 OHM의 가격이 1달러 아래로 떨어지게 되면 프로토콜이 OHM을 사들여 소각하고 OHM의 공급량을 줄임으로써 가격을 유지시킨다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#olympus-dao%EB%9E%80\">Olympus Dao란?</a></li>\n<li><a href=\"#ohm%EC%9D%98-%ED%8A%B9%EC%A7%95-ohm-is-backed\">OHM의 특징 (OHM Is Backed)</a></li>\n</ul>\n</div>","excerpt":"👋 Olympus Dao에 대하여 Olympus Dao란? Olympus Dao는 중앙은행을 대채하기 위해 나온 탈중앙호 준비통화 프로토콜이다. 현재 Defi 2.0으로 현재는 시가총액이 많이 떨어졌지만 Defi 생태계를 이끌어가는 선두주자라고 할 수 있다. 준비통화(Reserve Currency)란 준비 통화는 국가별로 지급을 대비해 보유한 외국환을 말한다.\r\nEx) 미국의 준비통화: 달러(Dollar), Olympus Dao의 준비통화: OHM Defi의 근본적인 목적을 달성하기 위해 Olympus Dao는 OHM이라는 준비통화를 사용한다. 달러의 경우 특정 집단(미 연준)이 통제권을 가지고 있다. 이에 반해서 Olympus Dao의 ohm은 커뮤니티가 통제권을 가지고 있다. 또한 커뮤니티가 앞으로의 방향성을 결정하며 투명하고 안정적인 준비통화 시스템을 만들어 나간다. OHM의 특징 (OHM Is Backed) 현재 대부분의 스테이블 코인들은 1달러에 pegged 되어있다. 즉…","frontmatter":{"date":"March 12, 2022","title":"Olympus Dao란(작성중)","categories":"Defi","author":"한성원","emoji":"🧢"},"fields":{"slug":"/defi/OlympusDao에대하여/"}},"next":{"id":"05f17d07-50cd-5a53-8a64-0774c3125c57","html":"<h1 id=\"-solidity-storage-layout-for-proxy-contracts-and-diamonds\" style=\"position:relative;\"><a href=\"#-solidity-storage-layout-for-proxy-contracts-and-diamonds\" aria-label=\" solidity storage layout for proxy contracts and diamonds permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>👋 Solidity Storage Layout For Proxy Contracts and Diamonds</h1>\n<p>이 글은 내가 공부하면서 찾은 <a href=\"https://medium.com/1milliondevs/solidity-storage-layout-for-proxy-contracts-and-diamonds-c4f009b6903\">이 글</a>을 변역하였다. 이 글은 Ethernaut의 24번 Puzzle Wallet을 풀때 공부했던 것을 봤다. 이 글을 읽기 위해서는 proxy contract에 대한 사전지식이 필요하다. 또한 이 글은 Diamond standard의 저자인 NickMudge의 글이며, Proxy contract의 Storage Layout과 Diamond standard에 대해서 다룬다. 글에는 내가 생각하는 부분이 포함되어있을 수도 있기 때문에, 내 글이 이해가 잘 되지 않는다면 <a href=\"https://medium.com/1milliondevs/solidity-storage-layout-for-proxy-contracts-and-diamonds-c4f009b6903\">원문</a>을 읽어보는 것을 추천한다.</p>\n<h3 id=\"시작\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EC%9E%91\" aria-label=\"시작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시작</h3>\n<p><code class=\"language-text\">Storage Layout</code>은 contract의 상태 변수가 <code class=\"language-text\">contract storage</code>에 저장되는 방법과 저장되는 위치이다.</p>\n<p><code class=\"language-text\">Storage Layout</code>은 우리가 평상시에 contract를 작성할 때는 고려하지 않아도 괜찮다. 왜냐하면 Solidity compiler가 알아서 처리해주기 때문이다.</p>\n<p>하지만 <code class=\"language-text\">Proxy contract</code> 또는 <code class=\"language-text\">Diamond</code>를 작성할때는 <code class=\"language-text\">Storage layout</code>을 고려하면 contract를 작성해야한다.</p>\n<p>이유를 설명하기 전에 contract storage와 상태변수 Layout에 대해서 먼저 이야기 해보자.1</p>\n<ol>\n<li>상태변수의 <code class=\"language-text\">Storage Layout</code>은 Slot 0에서 시작하며 새로운 상태변수마다 증가한다. Ex) 첫번째 상태변수는 Slot 0, 두번째는 Slot 1… (optimize 제외)</li>\n<li>struct와 array도 지정된 만큼에 공간을 차지하여 storage에 저장된다.</li>\n<li>동적 array와 mapping은 동적으로 크기가 변하기 때문에 storage위치와 key의 hash 값을 기반으로 하는 위치에 저장된다.</li>\n</ol>\n<p>Storage Layout의 작동 방식에 대한 설명은 <a href=\"https://solidity.readthedocs.io/en/v0.6.3/miscellaneous.html\">Solidity docs</a>에 잘 나와있다!</p>\n<p>즉 Storage Layout은 Slot 0에서 시작하여 새로운 상태변수가 올때마다 증가한다는 것을 알 수 있다.</p>\n<h3 id=\"problem\" style=\"position:relative;\"><a href=\"#problem\" aria-label=\"problem permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Problem</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">문제는 Proxy contract와 logic contract가 같은 storage layout을 공유한다는 것이다.</code></pre></div>\n<p>다음 코드는 문제에 대해 설명하기 위한 예시이다.</p>\n<p>ProxyA는 2개의 상태변수를 정의한다, facetA와 owner.</p>\n<div class=\"gatsby-highlight\" data-language=\"solidity\"><pre class=\"language-solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">contract</span> <span class=\"token class-name\">ProxyA</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token builtin\">address</span> facetA<span class=\"token punctuation\">;</span>  \r\n    <span class=\"token builtin\">address</span> owner<span class=\"token punctuation\">;</span>\r\n    <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token punctuation\">{</span>\r\n        owner <span class=\"token operator\">=</span> msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">;</span>\r\n        facetA <span class=\"token operator\">=</span> <span class=\"token number\">0x0b22380B7c423470979AC3eD7d3c07696773dEa1</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n    <span class=\"token function\">fallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span> <span class=\"token keyword\">payable</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token builtin\">address</span> facetAddress <span class=\"token operator\">=</span> facetA<span class=\"token punctuation\">;</span>\r\n        <span class=\"token keyword\">assembly</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> code omitted <span class=\"token keyword\">for</span> simplicity\r\n        <span class=\"token punctuation\">}</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br/>\n<p>FacetA는 하나의 상태변수를 정의한다.</p>\n<br/>\n<div class=\"gatsby-highlight\" data-language=\"solidity\"><pre class=\"language-solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">contract</span> <span class=\"token class-name\">FacetA</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token builtin\">address</span> user<span class=\"token punctuation\">;</span>\r\n    <span class=\"token keyword\">function</span> <span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span> <span class=\"token keyword\">view</span> <span class=\"token keyword\">returns</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">return</span> user<span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n    <span class=\"token keyword\">function</span> <span class=\"token function\">setUser</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> newUser<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span> <span class=\"token punctuation\">{</span>\r\n        user <span class=\"token operator\">=</span> newUser<span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span> \r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br/>\n<p>ProxyA contract는 FacetA에게 함수 호출을 위임(delegate)한다. 이때 문제는 위임시에 ProxyA와 FacetA는 <code class=\"language-text\">storage layout</code>을 공유한다는 것이다. ProxyA의 상태변수 <code class=\"language-text\">facet</code>는 slot 0에 위치한다. 또한 FacetA의 상태변수 <code class=\"language-text\">user</code>도 slot 0에 위치한다. 우리는 setUser를 통해 user만 바뀌는 것을 의도했지만, 만약 <code class=\"language-text\">setUser(address newUser)</code>가 호출된다면 <code class=\"language-text\">user</code>와 <code class=\"language-text\">facetA</code>가 모두 <code class=\"language-text\">newUser</code>로 바뀔 것이다.</p>\n<p>사람들은 이와 같은 문제를 해결하기위해 다양한 패턴을 만들었고 이제부터 그 패턴들에 대해서 설명해보겠다.</p>\n<h3 id=\"unstructured-storage\" style=\"position:relative;\"><a href=\"#unstructured-storage\" aria-label=\"unstructured storage permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Unstructured Storage</h3>\n<p>Solidity의 storage는 <code class=\"language-text\">assembly</code>를 통해서 contract storage에 임의로 위치를 정해 value를 저장할 수 있다. 이 패턴은 <code class=\"language-text\">Unstructured Storage Pattern</code>이다. 이 패턴의 예시를 함께 보자</p>\n<br/>\n<div class=\"gatsby-highlight\" data-language=\"solidity\"><pre class=\"language-solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">contract</span> <span class=\"token class-name\">ProxyA</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">function</span> <span class=\"token function\">getOwner</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">internal</span> <span class=\"token keyword\">view</span> <span class=\"token keyword\">returns</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> owner<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token builtin\">bytes32</span> position <span class=\"token operator\">=</span> <span class=\"token function\">keccak256</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"owner\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n        <span class=\"token keyword\">assembly</span> <span class=\"token punctuation\">{</span>\r\n            owner <span class=\"token operator\">:=</span> <span class=\"token function\">sload</span><span class=\"token punctuation\">(</span>position<span class=\"token punctuation\">)</span>\r\n        <span class=\"token punctuation\">}</span>\r\n    <span class=\"token punctuation\">}</span>\r\n    <span class=\"token keyword\">function</span> <span class=\"token function\">setOwner</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> owner<span class=\"token punctuation\">)</span> <span class=\"token keyword\">internal</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token builtin\">bytes32</span> position <span class=\"token operator\">=</span> <span class=\"token function\">keccak256</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"owner\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n        <span class=\"token keyword\">assembly</span> <span class=\"token punctuation\">{</span>\r\n            <span class=\"token function\">sstore</span><span class=\"token punctuation\">(</span>position<span class=\"token punctuation\">,</span> owner<span class=\"token punctuation\">)</span>\r\n        <span class=\"token punctuation\">}</span>\r\n    <span class=\"token punctuation\">}</span>\r\n    <span class=\"token keyword\">function</span> <span class=\"token function\">getFacet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">internal</span> <span class=\"token keyword\">view</span> <span class=\"token keyword\">returns</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> facet<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token builtin\">bytes32</span> position <span class=\"token operator\">=</span> <span class=\"token function\">keccak256</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"FacetA\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n        <span class=\"token keyword\">assembly</span> <span class=\"token punctuation\">{</span>\r\n            facet <span class=\"token operator\">:=</span> <span class=\"token function\">sload</span><span class=\"token punctuation\">(</span>position<span class=\"token punctuation\">)</span>\r\n        <span class=\"token punctuation\">}</span>\r\n    <span class=\"token punctuation\">}</span>\r\n    <span class=\"token keyword\">function</span> <span class=\"token function\">setFacet</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> facet<span class=\"token punctuation\">)</span> <span class=\"token keyword\">internal</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token builtin\">bytes32</span> position <span class=\"token operator\">=</span> <span class=\"token function\">keccak256</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"FacetA\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n        <span class=\"token keyword\">assembly</span> <span class=\"token punctuation\">{</span>\r\n            <span class=\"token function\">sstore</span><span class=\"token punctuation\">(</span>position<span class=\"token punctuation\">,</span> facet<span class=\"token punctuation\">)</span>\r\n        <span class=\"token punctuation\">}</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br/>\n<p>위 예시에서는 <code class=\"language-text\">get</code>과 <code class=\"language-text\">set</code> 함수를 이용해 <code class=\"language-text\">owner</code>와 <code class=\"language-text\">facetA</code>을 storage에 저장하고 가져올 수 있다. 우리는 상태변수가 저장되는 장소를 <code class=\"language-text\">assembly</code>를 사용해 지정함으로써 다른 storage 변수와 충돌되지 않도록 한 것이다. 충돌하지 않는다는 장점도 있지만, <code class=\"language-text\">Unstructured Storage Pattern</code>은 몇가지 단점이 존재한다.</p>\n<ol>\n<li>각 storage 변수에 대해서 getter와 setter를 정의해야한다.</li>\n<li>단순한 번수들에만 적용이 된다(<code class=\"language-text\">uint</code>, <code class=\"language-text\">address</code> 등). structs와 mappings에는 적용되기 힘들다.</li>\n</ol>\n<h3 id=\"inherited-storage\" style=\"position:relative;\"><a href=\"#inherited-storage\" aria-label=\"inherited storage permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Inherited Storage</h3>\n<p>Proxy contract와 logic contract 이외에 storage contract를 배포해 상속(Inherit)하는 방법이다. 이 방법을 사용하면 proxy 와 logic contract가 동일한 상태변수를 선언하기 때문에 충돌이 발생하지 않는다. 아래 예시를 보자!</p>\n<br/>\n<div class=\"gatsby-highlight\" data-language=\"solidity\"><pre class=\"language-solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">contract</span> <span class=\"token class-name\">Storage1</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token builtin\">address</span> owner<span class=\"token punctuation\">;</span>\r\n    <span class=\"token builtin\">address</span> facetA<span class=\"token punctuation\">;</span>\r\n    <span class=\"token builtin\">address</span> user<span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n<span class=\"token keyword\">contract</span> <span class=\"token class-name\">ProxyA</span> <span class=\"token keyword\">is</span> Storage1 <span class=\"token punctuation\">{</span>\r\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> code omitted <span class=\"token keyword\">for</span> simplicity\r\n<span class=\"token punctuation\">}</span>\r\n<span class=\"token keyword\">contract</span> <span class=\"token class-name\">FacetA</span> <span class=\"token keyword\">is</span> Storage1 <span class=\"token punctuation\">{</span>\r\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> code omitted <span class=\"token keyword\">for</span> simplicity\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br/>\n<p>위와 같은 contract를 배포하고 연결한 후에 logic contract를 추가로 생성할 수 있고 새로운 상태변수를 정의할 수도 있다. 이 방법은 새로운 storage contract를 배포하고 이전의 storage contract를 상속하는 방식으로 작동한다.</p>\n<p>예시를 한번 보자!</p>\n<div class=\"gatsby-highlight\" data-language=\"solidity\"><pre class=\"language-solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">contract</span> <span class=\"token class-name\">Storage2</span> <span class=\"token keyword\">is</span> Storage1 <span class=\"token punctuation\">{</span>\r\n    <span class=\"token builtin\">address</span> facetB<span class=\"token punctuation\">;</span>\r\n    <span class=\"token builtin\">address</span> nextUser<span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n<span class=\"token keyword\">contract</span> <span class=\"token class-name\">FacetB</span> <span class=\"token keyword\">is</span> Storage2 <span class=\"token punctuation\">{</span>\r\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> code omitted <span class=\"token keyword\">for</span> simplicity\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br/>\n<p><code class=\"language-text\">Storage2</code>는 ProxyA를 그대로 사용할 수 있다. 왜냐하면 <code class=\"language-text\">Storage2</code>의 새로운 상태변수들은 <code class=\"language-text\">Storage1</code>의 상태변수 뒤에 정의되기 때문이다.</p>\n<p>이 방식도 단점이 존재한다.</p>\n<ol>\n<li>Logic Contract들은 사용하지 않는 상태변수도 포함되어있는 Storage contract를 상속해야한다.</li>\n<li>Logic Contract는 특정 proxy contract와 연결되며 다른 상태변수를 선언하는 proxy cotnract 및 logic contract를 사용할 수 없다.</li>\n</ol>\n<br/>\n<!-- 이와 다르게 Diamond Storage는 단점이 존재하지 않는다.\r\n1. Proxy contracts, diamonds, Logic Contract는 자신들이 사용하는 Diamond Storage만 상속하면 된다. \r\n2. Diamond Storage는 proxy contrat와 Logic Contract를 분리시킬 수 있다. 또한 Diamond Storage를 사용하는 Logic contract는 다른 proxy contract 또는 logic contract와 같이 사용할 수 있다. Diamond Storage는 레고처럼 Logic contract와 proxy contract를 연결하거나 재사용 할 수 있게 해준다. -->\n<h3 id=\"eternal-storage\" style=\"position:relative;\"><a href=\"#eternal-storage\" aria-label=\"eternal storage permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Eternal Storage</h3>\n<p>Ethernal Storage는 Solidity의 <code class=\"language-text\">mappings</code>를 사용해 contract storage API를 만드는 것이다. 그래서 Proxy와 logic contract는 API를 이용해 충돌없이 storage를 사용 할 수 있다.</p>\n<p>아래 예시를 보며 더 이해해 보자!</p>\n<div class=\"gatsby-highlight\" data-language=\"solidity\"><pre class=\"language-solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">contract</span> <span class=\"token class-name\">ProxyA</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">mapping</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">bytes32</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">uint256</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">internal</span> uIntStorage<span class=\"token punctuation\">;</span>\r\n    <span class=\"token keyword\">mapping</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">bytes32</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">uint256</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">internal</span> uIntArrayStorage<span class=\"token punctuation\">;</span>\r\n    <span class=\"token keyword\">mapping</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">bytes32</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">internal</span> stringStorage<span class=\"token punctuation\">;</span>\r\n    <span class=\"token keyword\">mapping</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">bytes32</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">address</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">internal</span> addressStorage<span class=\"token punctuation\">;</span>\r\n    <span class=\"token keyword\">mapping</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">bytes32</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">bytes</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">internal</span> bytesStorage<span class=\"token punctuation\">;</span>\r\n    <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token punctuation\">{</span>\r\n        addressStorage<span class=\"token punctuation\">[</span><span class=\"token string\">\"owner\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">;</span>\r\n        addressStorage<span class=\"token punctuation\">[</span><span class=\"token string\">\"facetA\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0x0b22380B7c423470979AC3eD7</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n    <span class=\"token function\">fallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span> <span class=\"token keyword\">payable</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token builtin\">address</span> facetAddress <span class=\"token operator\">=</span> addressStorage<span class=\"token punctuation\">[</span><span class=\"token string\">\"facetA\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\r\n        <span class=\"token keyword\">assembly</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> code omitted <span class=\"token keyword\">for</span> simplicity\r\n        <span class=\"token punctuation\">}</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br/>\n<div class=\"gatsby-highlight\" data-language=\"solidity\"><pre class=\"language-solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">contract</span> <span class=\"token class-name\">FacetA</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">mapping</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">bytes32</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">uint256</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">internal</span> uIntStorage<span class=\"token punctuation\">;</span>\r\n    <span class=\"token keyword\">mapping</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">bytes32</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">uint256</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">internal</span> uIntArrayStorage<span class=\"token punctuation\">;</span>\r\n    <span class=\"token keyword\">mapping</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">bytes32</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">internal</span> stringStorage<span class=\"token punctuation\">;</span>\r\n    <span class=\"token keyword\">mapping</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">bytes32</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">address</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">internal</span> addressStorage<span class=\"token punctuation\">;</span>\r\n    <span class=\"token keyword\">mapping</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">bytes32</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">bytes</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">internal</span> bytesStorage<span class=\"token punctuation\">;</span>\r\n    <span class=\"token keyword\">function</span> <span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span> <span class=\"token keyword\">view</span> <span class=\"token keyword\">returns</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">return</span> addressStorage<span class=\"token punctuation\">[</span><span class=\"token string\">\"user\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n    <span class=\"token keyword\">function</span> <span class=\"token function\">setUser</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> newUser<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span> <span class=\"token punctuation\">{</span>\r\n        addressStorage<span class=\"token punctuation\">[</span><span class=\"token string\">\"user\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> newUser<span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br/>\n<p>위의 예시 같이 우리는 <code class=\"language-text\">mappings</code>를 사용해 상태변수를 저장하고 읽을 수 있다. 이렇게 해도 잘 작동하지만 단점이 분명 존재한다.</p>\n<ol>\n<li>상태변수를 다루기 힘든 문법</li>\n<li>기본적인 단순한 변수는 쉽게 사용될 수 있지만 <code class=\"language-text\">struct</code>와 <code class=\"language-text\">mapping</code>같은 경우 일반적인 방식으로 작동하지 않는다.</li>\n<li>Proxy contract와 모든 logic contract는 항상 같은 Storage API를 가지고 있어야한다.</li>\n<li>slot 순서대로 저장되는 것이 아니기 때문에 어떤 상태변수가 존재하는지 한눈에 확인할 수 없다.</li>\n</ol>\n<h3 id=\"conclusion\" style=\"position:relative;\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h3>\n<p>사람들은 Procy contract의 Storage Layout을 관리하기 위해 여러가지 방법을 생각해냈다.</p>\n<p>어떤 방법이 좋은지는 각자의 상황 및 취향에 따라 다르다. 하지만 어느 방법을 사용하든 단점이 존재한다. 그래서 나온 방법이 Diamond Storage이다. 다음 Post에서는 Diamond Storage에 대해서 다루겠다. Diamond Storage는 위 세가지 방법과 다르게 단점이 존재하지 않는다!</p>\n<h3 id=\"my-summary나에게-하는-말\" style=\"position:relative;\"><a href=\"#my-summary%EB%82%98%EC%97%90%EA%B2%8C-%ED%95%98%EB%8A%94-%EB%A7%90\" aria-label=\"my summary나에게 하는 말 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>My Summary(나에게 하는 말)</h3>\n<p>Proxy contract에 대해서 공부하며 찾은 글을 번역해보았다. Proxy contract를 처음 접했을 때는 막막하기만 했지만 좋은 글을 여러게 읽고나니 좀 이해가 되는 것 같다. Proxy에 대한 이론을 완벽하게 깨우친 후 직접 upgradable contract도 짜보자 <del>배우면 배울수록 배워야하는게 더 많아지는건 기분탓…?ㅎㅎ</del> 앞으로 꾸준히 배우자! 시간이 안되더라도 하루에 글 하나씩이라도 읽으며 익숙해지자. 화아팅!</p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EC%8B%9C%EC%9E%91\">시작</a></li>\n<li><a href=\"#problem\">Problem</a></li>\n<li><a href=\"#unstructured-storage\">Unstructured Storage</a></li>\n<li><a href=\"#inherited-storage\">Inherited Storage</a></li>\n<li><a href=\"#eternal-storage\">Eternal Storage</a></li>\n<li><a href=\"#conclusion\">Conclusion</a></li>\n<li><a href=\"#my-summary%EB%82%98%EC%97%90%EA%B2%8C-%ED%95%98%EB%8A%94-%EB%A7%90\">My Summary(나에게 하는 말)</a></li>\n</ul>\n</div>","frontmatter":{"date":"February 16, 2022","title":"Solidity Storage Layout For Proxy Contracts and Diamonds","categories":"EVM","author":"한성원","emoji":"🧢"},"fields":{"slug":"/EVM/StorageLayoutForProxy/"}},"prev":{"id":"818646bd-e689-5c01-908d-94c929a686b8","html":"<h1 id=\"-defi-10-vs-20\" style=\"position:relative;\"><a href=\"#-defi-10-vs-20\" aria-label=\" defi 10 vs 20 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>👋 Defi 1.0 vs 2.0</h1>\n<p>이번 글에서는 간단하게 Defi 1.0이 가지고 있던 문제, 그리고 Defi 2.0이 이를 어떻게 해결하였는가에 대해서 다룰 것이다. 기본적인 Defi에 대한 지식이 있다는 전제로 글을 썼다.</p>\n<h2 id=\"defi-10의-문제점\" style=\"position:relative;\"><a href=\"#defi-10%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"defi 10의 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Defi 1.0의 문제점</h2>\n<p>우선 Defi 1.0은 LP(Liquidity Pool)에 Liquidity 제공자에게 프로토콜의 코인으로 보상을 주는 메커니즘을 가지고 있다. 이 메커니즘을 통해 사용자를 끌어모을 수 있었고 단기간 큰 성장을 거둘 수 있었다. 하지만 Defi 1.0에 분명한 문제점이 존재했다.</p>\n<ol>\n<li>보상 코인의 가치가 하락\r\n- 예를 들어 유동성 제공자들이 A Token으로 보상을 받는다고 가정해보자. A Token은 보상이외에 다른 메리트가 없다. 그렇기 때문에 A Token 현금화하거나 더 가치있는 토큰을 매입하는데 사용 할 것이다. 그럼 자연적으로 A Token의 가치는 떨어질 것이다.</li>\n<li>이자율 하락\r\n- Defi 1.0 프로젝트가 커지면 커질수록 LP에 내가 제공한 유동성의 비율은 자연적으로 하락할 것이며 보상의 크기도 감소 할 것이다.</li>\n<li>새로은 디파이 프로젝트\r\n- 새로운 Defi 1.0 프로젝트가 런칭하면서 차별점으로 높은 APY와 혜택들을 제공 할 것이다. 새로운 프로젝트가 런칭 할 때마다 많은 자금이 이동 할 것이고 그 결과로 자연스럽게 보상 Token의 가치는 떨어질 것이다.</li>\n</ol>\n<p>Defi 1.0 은 이러한 구조적인 문제점을 가지고 있었기 때문에 장기적으로 살아날을 수 없었다.  그래서 사람들은 이 문제들을 해결하기 위해 새로운 메커니즘을 도입하여 Defi 2.0을 만들었다.</p>\n<h2 id=\"defi-20은-defi-10의-문제를-어떻게-해결하는가\" style=\"position:relative;\"><a href=\"#defi-20%EC%9D%80-defi-10%EC%9D%98-%EB%AC%B8%EC%A0%9C%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%B4%EA%B2%B0%ED%95%98%EB%8A%94%EA%B0%80\" aria-label=\"defi 20은 defi 10의 문제를 어떻게 해결하는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Defi 2.0은 Defi 1.0의 문제를 어떻게 해결하는가?</h2>\n<p>Olympus Dao를 기준으로 Defi 2.0에 대해서 설명하도록 하겠다.</p>\n<p>Defi 2.0은 위 문제들을 해결하기 위해 새로운 메커니즘을 도입했다. Defi 1.0에서는 User가 유동성을 제공했다면 Defi 2.0에서는 프로토콜이 유동성을 제공한다. 유동성을 공급 할 수 없는 대신 Bonding과 Staking을 통해 수익을 얻을 수 있다.</p>\n<p>1차적으로 User는 Bonding을 통해 시장에 형성된 가격보다 할인된 가격에 OHM 토큰(Olympus Dao의 토큰)을 구매할 수 있다. 대신 5일동안 자산이 Lock되고 5일 후에는 팔 수 있다. 만약 Bonding을 구매 했을때 가격과 5일 후 OHM의 가격이 같다면 할인율만큼 이득을 볼 수 있다.</p>\n<p>Bonding을 구매할 때는 다른 Coin 또는 Token을 사용하여 구매할 수 있으며, 구매에 사용된 자산은 프로토콜이 소유하게된다.</p>\n<p>Defi 1.0과 다르게 OHM을 보유한 자산과 교환해야하기 때문에 OHM의 가격을 유지 할 수 있다. 그리고 구매한 OHM을 Staking하여 이자를 받을 수 있다. 즉 User은 OHM을 구매하고 Staking함으로써 이자를 받을 수 있고, 프로토콜은 유동성을 제공할 수 있게된다.</p>\n<h2 id=\"추가-의견\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EA%B0%80-%EC%9D%98%EA%B2%AC\" aria-label=\"추가 의견 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추가 의견</h2>\n<p>최근 Defi 3.0에 대한 소식도 들리며 Defi 생태계는 빠르게 발전하는 중이라는 것을 느낀다. Defi가 자리를 잡기까지는 많은 시간이 소요 될 것이다. 하지만 기존의 시스템에 비해 모두에게 이로우며 혁신적이라는 사실은 변하지 않는다. 발전 과정을 지켜보며 나도 함께 성장 할 수 있을 것이라고 생각한다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치며</h2>\n<p>위 글로만 Defi를 이해하는 것은 불가능하다. 하지만 Defi 1.0의 문제와 2.0에 해결 방법에 대해서는 알 수 있었을 것이라고 생각한다. 다음 포스트에서는 Defi 2.0의 대표인 Olympus Dao에 대해서 분석할 예정이며 더 깊이 다뤄 볼 것이다.</p>\n<h3 id=\"ref\" style=\"position:relative;\"><a href=\"#ref\" aria-label=\"ref permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Ref</h3>\n<ul>\n<li><a href=\"https://docs.olympusdao.finance/main/\">https://docs.olympusdao.finance/main/</a></li>\n<li><a href=\"https://blockchainlaboratory.tistory.com/49\">https://blockchainlaboratory.tistory.com/49</a></li>\n<li><a href=\"https://talken.io/board/post/TOKEN_TALK/311393\">https://talken.io/board/post/TOKEN_TALK/311393</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#defi-10%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90\">Defi 1.0의 문제점</a></p>\n</li>\n<li>\n<p><a href=\"#defi-20%EC%9D%80-defi-10%EC%9D%98-%EB%AC%B8%EC%A0%9C%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%B4%EA%B2%B0%ED%95%98%EB%8A%94%EA%B0%80\">Defi 2.0은 Defi 1.0의 문제를 어떻게 해결하는가?</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%B6%94%EA%B0%80-%EC%9D%98%EA%B2%AC\">추가 의견</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n<ul>\n<li><a href=\"#ref\">Ref</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"March 12, 2022","title":"Defi 1.0 vs 2.0","categories":"Defi","author":"한성원","emoji":"🧢"},"fields":{"slug":"/defi/Defi_1.0vs2.0/"}},"site":{"siteMetadata":{"siteUrl":"https://holyhansss.github.io","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/defi/OlympusDao에대하여/","nextSlug":"/EVM/StorageLayoutForProxy/","prevSlug":"/defi/Defi_1.0vs2.0/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}