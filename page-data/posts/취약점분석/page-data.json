{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/취약점분석",
    "result": {"pageContext":{"currentCategory":"취약점분석","categories":["All","취약점분석","ethereum","feature"],"edges":[{"node":{"id":"a383fe22-c571-5867-90f4-765c6f6905d3","excerpt":"👋 1. CoinFlip Difficulty 3/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 동전 뒤집기 게임에서 10번 연속 예측 성공하기 코드 분석 분석은 주석에! 풀이를 위한 Setup RemixIDE를 사용한다.\r\nremix 사용법은 YouTube와 google에 많이 나와있으니 최신것으로 찾아보자!\r\n그리고 docs를 읽어본다면 사용법을 쉽게 익힐 수 있을 것이다. 한 가지 주의할 점은 CoinFlip은 remix에서 바로 deploy하는 것이 아니라 ethernauts에서 만든 instance의 주소를 가지고 addressAt을 누르면 된다.\r\n또한 우리는 Rinkeby Network를 사용하고 있으니 ENVIRONMENT를 “Injected Web3”를 선택해주어야 한다. 풀이 이 문제는 random으로 생성되는 값을 연속해서 맞추는 것이다.\r\n그리고 이 문제에서 주목해야 할 점은 randomness이다. solidity를 사용하여 randomn…","fields":{"slug":"/ethernauts/3_coinFilp_ethernauts/3_coinFlip_ethernauts/"},"frontmatter":{"categories":"취약점분석","title":"(Ethernauts 취약점 3) CoinFlip","date":"January 06, 2022"}},"next":{"fields":{"slug":"/vulnerability/tx.origin/tx_origin/"}},"previous":null},{"node":{"id":"b07cd563-6b17-5ce7-b7b0-e27977da9b90","excerpt":"👋 tx.origin txorigin vs msg.sender 주로 tx.origin은 msg.sender과 비교된다. 우선 우리가 잘 아는 msg.sender는 함수를 호출한 사람을 가리키는 주소이다.\r\ntx.origin을 보면 tx는 transaction을 뜻한다. 즉 transaction을 만든 address를 뜻한다. 만약 account에서 smart contract A로 transaction을 보낸다면 msg.sender와 tx.origin은 같을 것이다. 왜냐하면 transaction을 만든이와 transaction을 보낸 사람이 같기 때문이다. 그렇다면 account -> smart contract A -> smart contract B 순으로 transaction을 보낸다면 어떻게 될까? B의 관점에서 본다면 transaction을 만든이는 account이고 msg.sender은 A일 것이다.\r\n밑에 사진을 본다면 이해가 더 쉬울 것이다.\r\n Example Code …","fields":{"slug":"/vulnerability/tx.origin/tx_origin/"},"frontmatter":{"categories":"취약점분석","title":"(취약점 시리즈 8) tx.origin","date":"January 03, 2022"}},"next":{"fields":{"slug":"/ethernauts/2_fallout_ethernauts/2_fallout_ethernauts/"}},"previous":{"fields":{"slug":"/ethernauts/3_coinFilp_ethernauts/3_coinFlip_ethernauts/"}}},{"node":{"id":"9ef4750a-da30-5e5e-b7e4-982a60380ee5","excerpt":"👋 1. Fallout Difficulty 2/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 contract의 ownership을 뺐어오기 코드 분석 사실 fallout에서는 코드를 분석 할 필요가 없다.\r\n한번 코드를 읽어보고 밑으로!! 풀이 우리의 문제는 “contract의 ownership을 뺐어오기” 이다. Contract를 자세히 보면 constructor에 오타가 있는 것으로 보인다.\r\n그렇게되면 우리는 Fal1out()을 call함으로써 ownership을 가져올 수 있다 모든 코드는 console창에서 이루어진다.\r\nctrl + shift + i를 눌러 console창을 활성화 시키자 완료 후 Submit instance를 누르고 조금 기다리면 block이 mine되고, 부가설명 원래 constructor는 아래와 같이 contract의 이름과 동일하게 사용했다. 하지만 Solidity v0.5.0에서 constructor는 ‘constructo…","fields":{"slug":"/ethernauts/2_fallout_ethernauts/2_fallout_ethernauts/"},"frontmatter":{"categories":"취약점분석","title":"(Ethernauts 취약점 2) Fallout","date":"January 02, 2022"}},"next":{"fields":{"slug":"/ethernauts/1_fallback_ethernauts/1_fallback_ethernauts/"}},"previous":{"fields":{"slug":"/vulnerability/tx.origin/tx_origin/"}}},{"node":{"id":"fb9c5327-00bd-577e-aeb4-3402a45f6026","excerpt":"👋 1. Fallback Difficulty 1/10 직접 푼 Ethernauts 풀이를 적어보려고 한다. 취약점에 공부했던 취약점을 실제로 공격해보며 복습 및 실습을 해볼수 있어 좋은 것 같다. 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 contract의 ownership을 뺐어오기 contract의 balance를 0으로 만들기 코드 분석 분석은 주석에! 풀이 우리는 2가지의 문제를 풀어야 한다. contract의 ownership을 뺐어오기 contract의 balance를 0으로 만들기 차례차례 풀어보겠다.\r\n코드를 봤을 떄 contract의 ownership을 가져올 수 있는 방법은 2가지가 있다. contribute() receive() contribute()를 이용해 owner가 되려면 초기 owner의 contributions 1000 ether보다 더 큰 돈을 contract로 보내야 한다. 하지만 contribute()의 require을 보면 …","fields":{"slug":"/ethernauts/1_fallback_ethernauts/1_fallback_ethernauts/"},"frontmatter":{"categories":"취약점분석","title":"(Ethernauts 취약점 1) Fallback","date":"January 02, 2022"}},"next":{"fields":{"slug":"/vulnerability/dos_with_block_gas_limit/dos_block_gas_limit/"}},"previous":{"fields":{"slug":"/ethernauts/2_fallout_ethernauts/2_fallout_ethernauts/"}}},{"node":{"id":"e0e97a21-8a72-5a35-9c3f-9a61ee547457","excerpt":"👋 DoS(Denial of Service) With Block Gas Limit 들어가기전 GAS란 무엇인가? 이더리움 블록체인의 블록들은 각 블록마다 소비 할 수 있는 가스의 최대량이 정해져있다. 즉 각 블록이 소비할 수 있는 최대량을 넘어선다면 transaction들은 fail 하게된다. DoS With Block Gas Limit 연산당 Gas가 정해져 있으며 smart contract를 실행할 때 계산된다. Block Gas Limit DOS은 smart contract가 실행되고 Gas를 계산할때 최대 연산량을 초과하면 발생한다.\r\n예를 들어보겠다. 한 smart contract에 사용자가 많아짐에 따라 크기가 증가하는 Array가 있다. smart contract안에는 그 array 전체를 순환하는 작업이 있다. 처음에는 괜찮았으나 시간이 지날수록 Array가 커져 연상량이 증가한다. 연산량이 너무 많아져 Denial Of Service로 이어질 수 있다. 보다 잘 이…","fields":{"slug":"/vulnerability/dos_with_block_gas_limit/dos_block_gas_limit/"},"frontmatter":{"categories":"취약점분석","title":"(취약점 시리즈 7) DOS With Block Gas Limit","date":"December 31, 2021"}},"next":{"fields":{"slug":"/vulnerability/dos_with_unexpected_revert/dos_unexpected_revert/"}},"previous":{"fields":{"slug":"/ethernauts/1_fallback_ethernauts/1_fallback_ethernauts/"}}},{"node":{"id":"74712f9f-52f3-558c-ab49-7b3557819053","excerpt":"👋 Unexpected Revert Unexpected Revert란? Unexpected Revert는 이름에서 알 수 있듯이, 트랜잭션을 고의적 revert시킴으로써 스마트 계약이 작동되지 않는 상태로 만드는 취약성입니다. Example code 출처: https://solidity-by-example.org/hacks/denial-of-service/ 시나리오는 이렇다. KingOfEther of Ether Contract가 배포된다. 처음으로 A가 1 Ether를 claimThrone()에 보냄으로써 King이 된다. 다음으로 B가 2 Ether를 claimThrone()에 보냄으로써 B가 King으로 바뀐다. King이 바뀌기 전에 A에게 1 Ether를 refund 해준다. C가 KingOfEther의 주소와 함께 Attack contract를 배포한다. C는 Attack.attack을 3 Ether와 함꼐 호출한다. C는 C는 king이 되고 Attack contrac…","fields":{"slug":"/vulnerability/dos_with_unexpected_revert/dos_unexpected_revert/"},"frontmatter":{"categories":"취약점분석","title":"(취약점 시리즈 6) DOS With Unexpected Revert","date":"December 29, 2021"}},"next":{"fields":{"slug":"/vulnerability/front_running/front_running/"}},"previous":{"fields":{"slug":"/vulnerability/dos_with_block_gas_limit/dos_block_gas_limit/"}}},{"node":{"id":"b5bcc145-ea08-5f50-b709-61d75f38540e","excerpt":"👋 Front Running Front Running이란? transaction이 포함된 block이 생성되기까지 약간의 시간이 소요된다. 네트워크 참여자들(miners & full nodes)은 처리되기 전의 transcation을 볼 수 있다. 만약 네트워크 참여자가 악의적인 마음을 품는다면 이후에 일어날 transcation을 알 수 있고 이에 대한 정보를 악의적으로 사용할 수 있다. 즉 front running은 block이 채굴되기 전 transcation을 확인해 자신이 더 높은 값의 gas price를 지불하여 이득을 취하는 것이다. 예시를 본다면 더 이해가 잘 될 것이다. Example Code 이 코드는 간단한 추측 게임 코드이다.\r\nhash 값의 변환 전 단어 맞출시 10 ether를 contract에 있는 10 ether를 가져갈 수 있다. 시나리오는 이렇다. A가 FindThisHash contract를 10 ether를 포함해 배포한다. B가 hash의 변환…","fields":{"slug":"/vulnerability/front_running/front_running/"},"frontmatter":{"categories":"취약점분석","title":"(취약점 시리즈 5) Front Running","date":"December 27, 2021"}},"next":{"fields":{"slug":"/vulnerability/delegate_call/delegate_call/"}},"previous":{"fields":{"slug":"/vulnerability/dos_with_unexpected_revert/dos_unexpected_revert/"}}},{"node":{"id":"4ce78d24-2527-55dd-87de-8312b5de194b","excerpt":"👋 DelegateCall 들어가기전 Call 과 Delegate Call의 차이점 Call이란? Call은 다른 contract와 상호작용하기 위한 low level function이다. 컨트랙트 A를 통해 컨트랙트 B의 함수 호출시 B의 Storage를 변경시키며 msg.sender(호출자)는 컨트랙트A의 주소가 됩니다. Delegate Call이란? delegate call은 call과 매우 유사하다. delegate은 ‘위임하다’ 라는 뜻으로 call에 대한 권한을 위임한다고 볼 수 있다. Delegate Call에는 2가지 특징이 있다. 호출한 contract의 context를 기반으로 동작된다. storage layout은 delegatecall을 이용하는 contract와 같아야한다. 예를 들어 컨트랙트 A를 통해 컨트랙트 B 호출시 B의 Storage를 변경시키지 않고, B의 코드를 A에서 실행합니다. msg.sender와 msg.value가 컨트랙트 A 호출시와 같…","fields":{"slug":"/vulnerability/delegate_call/delegate_call/"},"frontmatter":{"categories":"취약점분석","title":"(취약점 시리즈 4) Delegate Call","date":"December 26, 2021"}},"next":{"fields":{"slug":"/vulnerability/block_timestamp/block_timestamp/"}},"previous":{"fields":{"slug":"/vulnerability/front_running/front_running/"}}},{"node":{"id":"61d64787-9a91-539d-8e79-abcc19096677","excerpt":"👋 block.timestamp block.timestamp란? block.timestamp는 msg.sender처럼 블록체인에서 제공해주는 global 변수 중 하나이다. 이는 블록 생성 시간을 나타낸다.\r\n블록체인의 timestamp는 생성 시점에 데이터가 존재했다는 사실을 증명해주기 때문에 블록체인 자체에 매우 중요하다. 왜 취약점 시리즈에 들어갔을까? 바로 block.timestamp는 채굴자(miner)들에게 영향을 받을 수 있기 때문이다. 즉 block.timestamp를 통해 random을 생성하거나 block.timestamp와 관련해서 접근할 수 있는 함수가 있다면 smart contract에게 좋지 않은 영향을 끼칠 수 있다. Example code 출처: https://solidity-by-example.org/hacks/block-timestamp-manipulation/ 위 코드를 실행시켜 볼 수는 있지만 실제 해킹 실습까지 해보는 것은 어려울 것이라고 생각…","fields":{"slug":"/vulnerability/block_timestamp/block_timestamp/"},"frontmatter":{"categories":"취약점분석","title":"(취약점 시리즈 3) block.timestamp","date":"December 22, 2021"}},"next":{"fields":{"slug":"/vulnerability/over_under_flow/over_under_flow/"}},"previous":{"fields":{"slug":"/vulnerability/delegate_call/delegate_call/"}}},{"node":{"id":"957cc097-e5ab-5c01-a410-7e2216f8f744","excerpt":"👋 Over & UnderFlow 들어가기 전 Overflow와 Underflow는 solidity 0.8.0 버전부터 알아서 컨트롤 되게 바뀌었다.\r\n0.8.0 이후 버전을 사용하시는 분은 아래로 내려가도 좋다. OverFlow와 UnderFlow란 Overflow는 지정된 정수형(int)의 최댓값보다 커졌을 때 발생한다. Underflow는 지정된 정수형(uint)의 최솟값보다 작아졌을 때 발생한다.\r\nSolidity에서는 unsigned Integer(uint)를 자주 사용한다. uint256을 기준으로 했을때 최대값은 2256-1이고 최소값은 0이다. 즉 2256-1에 1을 더했을때 Overflow 0에서 1을 뺐을때 underflow가 일어날 것이다. ExampleColde를 보면 보다 쉽게 이해 할 수 있을 것이다. Example Code remix IDE에서 실습을 진행한다면 이해가 더욱 빠를것이다! 출처: https://medium.com/loom-network-ko…","fields":{"slug":"/vulnerability/over_under_flow/over_under_flow/"},"frontmatter":{"categories":"취약점분석","title":"(취약점 시리즈 2) Over & Under Flow?","date":"December 21, 2021"}},"next":{"fields":{"slug":"/vulnerability/reentrancy_attack/reentrancy_attack/"}},"previous":{"fields":{"slug":"/vulnerability/block_timestamp/block_timestamp/"}}},{"node":{"id":"5af0743e-deb7-5f3d-ae88-aa765fa5ca31","excerpt":"👋 Reentrancy Attack (재진입 공격) 들어가기전 Fallback 함수? Fallback 함수는 contract에서 함수를 실행시킬때 함수가 존재하지 않는다면 실행되는 function이다.\r\n0.6이전 버전에서는 fallback이 ether는 것과 존재하지 않는 함수의 대비책으로 사용되었지만 0.6 이후 버전부터 fallback은 fallback과 receive로 나누어졌다. 0.6부터는 fallback을 사용하지 않고 receive를 통해 이더를 받을 수 있다. Reentrancy Attack(재진입 공격)이란? Reentrancy Attack은 contract A가 하나의 user로써 contract B 에게 transaction을 보낸다. 이때 contract A가 요청에 대한 제어권을 가지게된다. 그렇게 되면 contract A가 보낸 첫번째 요청이 끝나기 전에 다른 함수를 계속해서 호출 할 수 있게된다. 이는 재진입을 ether를 빼올 수 있게 된다. Exam…","fields":{"slug":"/vulnerability/reentrancy_attack/reentrancy_attack/"},"frontmatter":{"categories":"취약점분석","title":"(취약점 시리즈 1) Reentrancy Attack (재진입 공격)?","date":"December 20, 2021"}},"next":{"fields":{"slug":"/ethereum/evm/"}},"previous":{"fields":{"slug":"/vulnerability/over_under_flow/over_under_flow/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}