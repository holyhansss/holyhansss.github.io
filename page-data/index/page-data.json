{
    "componentChunkName": "component---src-pages-index-js",
    "path": "/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"215ce45f-a0f2-56b0-9e68-03c15217730c","excerpt":"👋 시리즈 별 정리 시리즈 별로 보기 편하게 정리해두었다! Defi Defi 1.0 vs 2.0 UniswapV2 Core Factory Contract UniswapV2 Core Pair Contract EVM EVM과 Transaction Solidity Bytecode and Opcode Basics Solidity Storage Layout For Proxy Contracts and Diamonds 취약점 시리즈 취약점 시리즈는 알려진 smart contract의 취약점에 대해 다룬다. 취약점 시리즈 1 Reentrancy Attack 재진입 공격 취약점 시리즈 2 Overflow & Underflow 취약점 시리즈 3 block.timestamp 취약점 시리즈 4 Delegate Call 취약점 시리즈 5 Front Running 취약점 시리즈 6 DOS With Unexpected Revert 취약점 시리즈 7 DOS With Block Gas Limit 취약점 시리즈 …","frontmatter":{"categories":"~feature~","title":"시리즈 별 정리(모든 글이 다 여기 정리되어 있어요!)","date":"January 01, 2099"},"fields":{"slug":"/allSeries/"}}},{"node":{"id":"821f1e32-3206-5b8d-a50f-3a97ef9cee8d","excerpt":"👋 TWAP - Time Weighted Average Price 수학에 재능이 없는 나\r\nDefi에 들어가 있는 수식에 대한 이해를 더하기 위해 TWAP에 대해서 배우게 되었다. Twap이란 TWAP(Time Weighted Average Price)이란 본래 미국 주식 매수 주문 종류중 하나로 시간을 동일하게 나누어 동일한 수량을 기계적으로 주문하는 방법이다. 즉 지정된 시간동안의 평균 가격인 것이다. 주식에서와 다르게 uniswap은 On-Chain Oracle을 제공하기 위해 Twap을 사용하였다. 이번 글에서는 Twap에 대해서 알아보도록 할 것이고, UniswapV2가 이를 어떻게 사용하고 있는지 알아볼 것이다. TWAP 예시 1  위 사진을 예로 들어보겠다. 이 사진의 Average Price는 어떻게 구할까?\r\n수식으로 나타내면  일 것이고 으로 나타낼 수 있다. 조금 더 복잡한 예시를 통해 수식을 만들어보자 TWAP 예시 2  우리는 T0에서 Tn까지의 TWAP을 …","frontmatter":{"categories":"Defi","title":"TWAP(Time Weighted Average Price) - Defi Math","date":"April 28, 2022"},"fields":{"slug":"/defi/Defi_Math/Defi_Math_TWAP/"}}},{"node":{"id":"b389485f-ee0d-5b37-946f-6eb333a7c111","excerpt":"👋 Uniswap V2 Core Pair 저번주에 Uniswap Factory Contract 분석을 해봤다. Factory는 생각보다는 코드가 쉬웠지만 Pair은 조금 더 어려워 보인다! Pair Contact는 여기서 확인할 수 있고 Pair 분석 전 Factory Contract 분석을 보고오면 좋을 것 같다. Uniswap V2 Pair Interface 이 Interface에는 UniswapERC20 token의 interface도 포함되어 있는 것으로 보인다.\r\n실제 repository를 확인해 보면 UniswapERC20 token의 Interface도 따로 존재한다.\r\nPair contract는 Factory contract를 통해 pool 별로 배포된다. 그리고 그 안에서 swap이 일어나는 것으로 보인다.\r\n직접 코드를 더 봐야할 것 같지만 Uniswap이라는 이름에서 알 수 있듯이  이라는 함수가 이 contract에서 가장 중요해 보인다. 을 중심으로 Pair…","frontmatter":{"categories":"Defi","title":"Uniswap V2 Core Pair Contract 분석","date":"April 27, 2022"},"fields":{"slug":"/defi/UniswapV2/uniswapV2CorePair/"}}},{"node":{"id":"4c2748d1-cc77-5ed3-a092-61321e863d44","excerpt":"👋 Uniswap V2 Periphery Router Uniswap V2 Periphery Router에는 와 , 두가지 Router가 존재한다. Router01에서 문제가 발견되어 Router02를 만들었다고 한다. 그래서 이번 글에서는 Router02 contract를 다루려고한다. 우선 periphery contract는 Core contract의 함수들을 보다 쉽게 사용하기위해 만들어졌다. 우리가 지금 Uniswap 웹페이지에서 사용하는 contract가 바로 periphery contract이다. 이 글을 읽기 전 Core contract를 어느정도는 이해하여야 Uniswap의 전체적인 구조를 파악하는데 도움이 될 것이다. Uniswap V2 Periphery Router 주요 functions Router02에는 26개의 function이 존재한다. 26개의 function을 모두 글로 적기에는 양이 너무 많아 가장 중요한 몇가지 함수들만 다루려고 한다. addLiqui…","frontmatter":{"categories":"Defi","title":"Uniswap V2 Periphery Router Contract 분석","date":"April 27, 2022"},"fields":{"slug":"/defi/UniswapV2/uniswapV2PeripheryRouter/"}}},{"node":{"id":"da505b00-fcee-5e9c-957e-2897a5b358f0","excerpt":"👋 Uniswap V2 Core Factory Uniswap V2는 Core와 Periphery로 나뉜다. Core은 Factory 와 Pair을 중심으로 이루어져 있으며 Core 말 그대로 Uniswap의 심장 역할을 한다. Periphery는 직역하면 주변부라는 뜻으로 실제 유저들이 상호작용을 하는 contract이다. 오늘은 Uniswap V2 Factory contract 하나에 대해서 분석을 해볼 것이다! Uniswap V2 Factory Interface 우선 UniswapV2 Factory Contract의 Interface를 보자. 총 8개의 function과 1개의 event가 존재한다. 이름만 보며 각각의 기능들을 유추해보자! feeTo(): fee를 지불할 주소를 return한다. feeToSetter(): fee를 지불할 주소를 set한다. getPair(): tokenA와 tokenB의 pair 주소를 return한다. allPairs(): index를 받고…","frontmatter":{"categories":"Defi","title":"Uniswap V2 Core Factory Contract 분석","date":"April 19, 2022"},"fields":{"slug":"/defi/UniswapV2/uniswapV2CoreFactory/"}}},{"node":{"id":"6831d91d-3de3-5817-9dec-53365624c8da","excerpt":"👋 EIP-2981에 대하여 (Royalty Standard) -> 재판매 수수료 무엇이며 왜 등장하였나? EIP-2981은 NFT(Non-Furgable Token)에 대한 Royalty(재판매 수수료) 지급 정보를 저장해두는 표준이다. 현재 NFT의 Royalty 좀 이상하다. 진짜 말 그대로 이상하다.\r\n 예를 들에 OpenSea에서 A가 작품을 민팅하여 판다고 가정해보자. 그리고 10%의 royalty를 적용했다고 생각해보자. A는 Opensea를 사용해 B에게 작품 판매를 통해 돈을 벌었다. B는 Opensea에서 다시 작품을 C 판매해 수익의 90%를 챙긴고, 10%는 A에게 돌아간다. C는 Opensea가 아닌 Rarible에가서 작품을 재판매 했다. C는 돈을 받지만 A는 작품에 대한 Royalty를 받지 못한다. 현재 대부분의 marketplace는 Royalty에 대해서 호환되지 않는다.\r\n이 부분을 보안하기 위해서 EIP-2981이 등장하게 되었다. 저장수장이라…","frontmatter":{"categories":"NFT","title":"EIP-2981에 대하여 (Royalty Standard)","date":"March 29, 2022"},"fields":{"slug":"/NFT/EIP-2981에대하여/EIP-2981에대하여/"}}},{"node":{"id":"818646bd-e689-5c01-908d-94c929a686b8","excerpt":"👋 Defi 1.0 vs 2.0 이번 글에서는 간단하게 Defi 1.0이 가지고 있던 문제, 그리고 Defi 2.0이 이를 어떻게 해결하였는가에 대해서 다룰 것이다. 기본적인 Defi에 대한 지식이 있다는 전제로 글을 썼다. Defi 1.0의 문제점 우선 Defi 1.0은 LP(Liquidity Pool)에 Liquidity 제공자에게 프로토콜의 코인으로 보상을 주는 메커니즘을 가지고 있다. 이 메커니즘을 통해 사용자를 끌어모을 수 있었고 단기간 큰 성장을 거둘 수 있었다. 하지만 Defi 1.0에 분명한 문제점이 존재했다. 보상 코인의 가치가 하락\r\n- 예를 들어 유동성 제공자들이 A Token으로 보상을 받는다고 가정해보자. A Token은 보상이외에 다른 메리트가 없다. 그렇기 때문에 A Token 현금화하거나 더 가치있는 토큰을 매입하는데 사용 할 것이다. 그럼 자연적으로 A Token의 가치는 떨어질 것이다. 이자율 하락\r\n- Defi 1.0 프로젝트가 커지면 커질수록 L…","frontmatter":{"categories":"Defi","title":"Defi 1.0 vs 2.0","date":"March 12, 2022"},"fields":{"slug":"/defi/Defi_1.0vs2.0/"}}},{"node":{"id":"ac979ac3-92fb-532c-a651-d2167e935b53","excerpt":"👋 Olympus Dao에 대하여 Olympus Dao란? Olympus Dao는 중앙은행을 대채하기 위해 나온 탈중앙호 준비통화 프로토콜이다. 현재 Defi 2.0으로 현재는 시가총액이 많이 떨어졌지만 Defi 생태계를 이끌어가는 선두주자라고 할 수 있다. 준비통화(Reserve Currency)란 준비 통화는 국가별로 지급을 대비해 보유한 외국환을 말한다.\r\nEx) 미국의 준비통화: 달러(Dollar), Olympus Dao의 준비통화: OHM Defi의 근본적인 목적을 달성하기 위해 Olympus Dao는 OHM이라는 준비통화를 사용한다. 달러의 경우 특정 집단(미 연준)이 통제권을 가지고 있다. 이에 반해서 Olympus Dao의 ohm은 커뮤니티가 통제권을 가지고 있다. 또한 커뮤니티가 앞으로의 방향성을 결정하며 투명하고 안정적인 준비통화 시스템을 만들어 나간다. OHM의 특징 (OHM Is Backed) 현재 대부분의 스테이블 코인들은 1달러에 pegged 되어있다. 즉…","frontmatter":{"categories":"Defi","title":"Olympus Dao란(작성중)","date":"March 12, 2022"},"fields":{"slug":"/defi/OlympusDao에대하여/"}}},{"node":{"id":"7923f940-38ae-5c36-a122-da0d6bd4fc82","excerpt":"👋 졸업 프로젝트의 리더가 되었다. 이번 글에서는 우리 졸업 프로젝트에 리더가 필요했던 이유와 리더가 된 내가 드는 고민 및 생각을 써내려 갈 것이다. 팀의 리더가 생기면서 팀의 효율성이 좋아졌다고 느낀다. 요즘 많은 기업들에서도 수평적인 문화를 만들어 나가려고 노력한다.\r\n하지만 수평적인 관계라도 누군가는 리더로써 이끌어 나가고 있다. 우리 팀은 수평이라는 키워드에만 너무 몰입해 효율성을 떨어뜨리고 있었다.\r\n이번에 리더의 필요성을 느끼면서 리더라는 사람에 대한 이해가 깊어진 것 같다. 앞으로 내가 리더로써의 역할을 수행하면서 더 많은 것을 배울 것이라고 생각한다. 아래 글은 내가 리더가 된 과정을 그저 일기처럼 담았다. 이번 글에서는 과정을 담았고 나중 글에서는 리더가 된 후의 나의 마음가짐에 대해서 다룰 것이다. 졸업 프로젝트 팀에 대해, 그리고 리더가 되다. 졸업을 1년정도 앞두고 있는 지금, 나는 캡스톤 프로젝트를 시작하게 되었다.\r\n작년 말 6명의 팀원들을 만났고, 1월…","frontmatter":{"categories":"나","title":"리더가 되었다.","date":"March 05, 2022"},"fields":{"slug":"/about_me/리더가 되었다/리더가되었다/"}}},{"node":{"id":"05f17d07-50cd-5a53-8a64-0774c3125c57","excerpt":"👋 Solidity Storage Layout For Proxy Contracts and Diamonds 이 글은 내가 공부하면서 찾은 이 글을 변역하였다. 이 글은 Ethernaut의 24번 Puzzle Wallet을 풀때 공부했던 것을 봤다. 이 글을 읽기 위해서는 proxy contract에 대한 사전지식이 필요하다. 또한 이 글은 Diamond standard의 저자인 NickMudge의 글이며, Proxy contract의 Storage Layout과 Diamond standard에 대해서 다룬다. 글에는 내가 생각하는 부분이 포함되어있을 수도 있기 때문에, 내 글이 이해가 잘 되지 않는다면 원문을 읽어보는 것을 추천한다. 시작 은 contract의 상태 변수가 에 저장되는 방법과 저장되는 위치이다. 은 우리가 평상시에 contract를 작성할 때는 고려하지 않아도 괜찮다. 왜냐하면 Solidity compiler가 알아서 처리해주기 때문이다. 하지만  또는 를 작성할때는…","frontmatter":{"categories":"EVM","title":"Solidity Storage Layout For Proxy Contracts and Diamonds","date":"February 16, 2022"},"fields":{"slug":"/EVM/StorageLayoutForProxy/"}}},{"node":{"id":"f4a92826-91ef-5c1f-86ae-bc51ccfdf68f","excerpt":"👋 1. Puzzle Wallet Difficulty 7/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 들어가기 전 코드 분석 분석은 주석에 있습니다! 풀이 token1과 2, 모두가 balance가 0이 된 것을 확인했다면 ethernaut으로 돌아와 Submit instance를 누르고 조금 기다리면 block이 mine되고, 아래와 같이 뜨며 마무리된다. 마무리 REF rinkeyb network ether faucet: https://faucets.chain.link/rinkeby ethernaut: https://ethernaut.openzeppelin.com/ remix IDE: https://remix.ethereum.org 승리 조건 들어가기 전 코드 분석 풀이 마무리 REF","frontmatter":{"categories":"취약점분석","title":"(Ethernaut 취약점 24) Puzzle Wallet","date":"February 13, 2022"},"fields":{"slug":"/ethernaut/24_PuzzleWallet_etheranut/24_PuzzleWallet_etheranut/"}}},{"node":{"id":"93af762f-86c5-5ac5-822e-d23ffaf190d8","excerpt":"👋 1. Dex Two Difficulty 4/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 DexTwo Contract의 Token 1과 Token 2의 balance를 전부 소진하기 들어가기 전 Dex contract와 마찬가지고 DexTwo contact도 DEX와 ERC20에 대한 지식이 있어야 한다. Uniswap의 코드를 전부 분석하지는 못하더라도 작동원리에 대해서는 알아야한다.\r\n또한 ERC20 standard에 어떤 function이 필요한지, 어떻게 작동하는지 공부해야한다.\r\n아래 링크들을 통해 충분히 익숙해 진 후 풀기를 권장한다. 링크 이외에 Youtube에도 좋은 자료들이 많다! Uniswap openzeppelin ERC20 contract 코드 분석 분석은 주석에 있습니다! 풀이 이번 문제에서 우리는 Dex가 가진 모든 토큰을 소모하면 된다. 22번 Dex 문제를 잘 이해하고 있어야 풀 수 있다.\r\n그렇다면 어떻게 소모할 수 있을까? …","frontmatter":{"categories":"취약점분석","title":"(Ethernaut 취약점 23) Dex Two","date":"February 11, 2022"},"fields":{"slug":"/ethernaut/23_dexTwo_ethernaut/23_dexTwo_ethernaut/"}}},{"node":{"id":"0d2a86d4-1a71-582e-9b1d-f6df2fd99a18","excerpt":"👋 1. Dex Difficulty 3/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 Dex Contract 해킹 후 토큰 중 하나를 모두 소진(0으로 만들기)하는 것이다. 들어가기 전 이번 문제는 DEX와 ERC20에 대한 지식이 없다면 풀수 없는 문제이다.\r\nUniswap의 코드를 전부 분석하지는 못하더라도 작동원리에 대해서는 알아야한다.\r\n또한 ERC20 standard에 어떤 function이 필요한지, 어떻게 작동하는지 공부해야한다.\r\n아래 링크들을 통해 충분히 익숙해 진 후 풀기를 권장한다. 링크 이외에 Youtube에도 좋은 자료들이 많다! Uniswap openzeppelin ERC20 contract 코드 분석 분석은 주석에 있습니다! 풀이 이번 문제에서 우리는 Dex가 가진 모든 토큰을 소모하면 된다.\r\n그렇다면 어떻게 소모할 수 있을까? 힌트를 보자 Token의 가격이 어떻게 계산되는가? How is the price of the token…","frontmatter":{"categories":"취약점분석","title":"(Ethernaut 취약점 22) Dex","date":"February 10, 2022"},"fields":{"slug":"/ethernaut/22_dex_ethernaut/22_dex_ethernaut/"}}},{"node":{"id":"4c861eb3-aac1-5c8e-8244-16279e420295","excerpt":"👋 1. Shop Difficulty 4/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 contract에서 제시한 price보다 낮은 가격에 item 사기 코드 분석 분석은 주석에 있습니다! 풀이 들어가기 전 먼저 힌트를 보자 구매자가 사용할 상점 View 기능의 제한 사항 이해 (<- 중요한 부분) 우리는 view의 기능을 사용해 문제를 풀 수 있다.\r\n 풀이 view를 어떻게 사용해야 Shop contract를 해킹 할 수 있을까?\r\n다음 AttackContract를 확인해보자 이 문제는 Eelevator 문제와 비슷한 문제이다. 위 코드를 가지고 공격 시나리오를 생각해보자 attackShop contract를 Shop의 address를 인자로하여 배포한다. attackShop.attack()을 실행시킨다. Shop.buy()에서 if문을 통과하고 isSold가 true로 바뀐다. attackShop.price()는 isSold가 true기 때문에 Shop…","frontmatter":{"categories":"취약점분석","title":"(Ethernaut 취약점 21) Shop","date":"February 07, 2022"},"fields":{"slug":"/ethernaut/21_shop_ethernaut/21_shop_ethernaut/"}}},{"node":{"id":"b92a313c-04e6-5c0c-b35e-ffd7967cb3ba","excerpt":"👋 1. Denial Difficulty 5/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 Owner가 withdraw하지 못하게하면 승리한다. Owner 인출불가 상태 만들기 코드 분석 분석은 주석에 있습니다! 풀이 들어가기 전 이 문제는 call과 transfer의 차이를 잘 알아야 풀 수 있는 문제이다. transfer 수신 스마트 계약에는 fallback 함수가 정의되어 있어야 한다. 그렇지 않으면 전송 호출에 오류가 발생한다. 은 가스 제한량은 2300으로 을 완료하기에 한 양이다. send 과 유사한 방식으로 작동하며 가스 제한도 2300이다. 하지만 과 다르게 status를  값으로 반환한다. call smart contract에 ETH를 보내는 권장되는 방법이다. call의 빈 인수는 수신 주소의 fallback 함수를 실행시킨다. 을 사용하여 contract에 정의된 다른 기능을 실행시키고 함수를 실행하기 위해 고정된 양의 가스를 보낼 수도 있…","frontmatter":{"categories":"취약점분석","title":"(Ethernaut 취약점 20) Denial","date":"February 07, 2022"},"fields":{"slug":"/ethernaut/20_denial_ethernaut/20_denial_ethernaut/"}}},{"node":{"id":"b39f1c1a-2743-5cc2-b636-42969923ae17","excerpt":"👋 1. Alien Codex Difficulty 7/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 Alien contract의 ownership 가져오기 코드 분석 분석은 주석에 있습니다! 풀이 들어가기 전 이 문제에서 우리의 목표는 Alien contract의 ownership 가져오는 것이다. 우선 힌트를 보자! array storage가 어떻게 작동하는지 이해해야한다. ABI의 특징을 이해해야한다. Using a very underhanded approach -> 아마 underhanded solidity contest에 관해 말하는 것 같은데… 그것처럼 풀라는건가? 정확히는 모르겠다. 추후 알게되면 업데이터하도록 하겠다! 우리의 승리 조건은 owner를 가져오는 것이지만 코드를 아무리 둘러봐도 를 바꿀 수 있는 function은 존재하지 않는다. 하지만 모든 은 동인한 에 저장된다. 만약 우리가 모든 storage에 대한 access를 가진다면 어떻게…","frontmatter":{"categories":"취약점분석","title":"(Ethernaut 취약점 19) Alien Codex","date":"February 05, 2022"},"fields":{"slug":"/ethernaut/19_alienCodex_ethernaut/19_alienCodex_ethernaut/"}}},{"node":{"id":"53248b34-8ebe-58d2-a38d-f05c5d2ab26a","excerpt":"👋 1. Recovery Difficulty 6/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 들어가기 전 필자는 이 문제를 풀기까지 거의 일주일 이상 걸린 것 같다. 그만큼 어려웠고 어려웠던만큼 배우는 것이 많았다.\r\n이 문제를 푸는 여러분도 문제를 통해 EVM에 대해 배우는 것이 많기를 바란다.\r\n이 문제는 이 글을 기반으로 작성되었다.\r\n19번 문제를 풀때는 답을 찾아보고 왜 그 답이 올바른 답인지 찾는 과정으로 풀었다. 위 글은 19번의 답을 가장 잘 설명하고 있다고 생각하여 인용하였다.\r\n또한 내가 공부할때 봤던 사이트, 유투브 영상들의 리스트를 공유하니, 잘 모른다면 아래 자료들을 보고 공부해도 좋을 것 같다. Solidity Bytecode and Opcode Basics Openzeppelin Deconstructing a Solidity Contract EVM: From Solidity to byte code, memory and storage(Conse…","frontmatter":{"categories":"취약점분석","title":"(Ethernaut 취약점 18) MagicNumber","date":"February 04, 2022"},"fields":{"slug":"/ethernaut/18_magicNumber_ethernaut/18_magicNumber_ethernaut/"}}},{"node":{"id":"3765baae-a0e3-5a83-8f76-819456c68e51","excerpt":"👋 30개의 글을 쓰면서 느낀점  블로그를 시작한지 약 한달 반이 지났다. 초보 블로거로서 약 30개 정도의 블로그 글을 적으며 글쓴이로써 부족한 점을 많이 느낀다. 그래서 글을 적으며 배운점 및 느낀점을 적어내려가보려고 한다. 이 블로그의 최초 목적은 기술 블로그였다. 내가 배우고 있는 기술에 대해 기록하는 것이 목적인. 그렇기에 내가 공부한 것을 토대로 글을 쓴다. 글을 쓰다 문득 느끼는 점은 나는 무엇을 위해 글을 쓰는가였다. 생각해보면 나는 아래 두가지 목적을 위해 글을 쓰기 시작하는 것 같다. 나의 발전을 위하여 남의 발전을 위하여 1번 나의 발전을 위하여. 나는 공부를 하면서 내가 공부했던 것들을 돌아볼때가 많다. 문제들을 해결해가다보면 겹치는 부분이 있고, 내가 공부했던 내용을 보면 이해가 더 잘된다. 기록은 나의 발전에 있어서 큰 기어를 하고 있다고 느낀다. 아직 한달밖에 지나지 않았기에 정말 많은 발전이 있었다고는 말하지 못하겠다. 하지만 일년이 지난다면 다른 기술…","frontmatter":{"categories":"나","title":"30개의 글을 쓰면서 느낀점","date":"February 01, 2022"},"fields":{"slug":"/about_me/impression_30posts/impression_1/"}}},{"node":{"id":"e2daae35-e3b2-59dc-8d41-71dd41acfbfe","excerpt":"👋 Solidity Bytecode and Opcode Basics 이 글은 내가 공부하면서 찾은 이 글을 변역하였다. 이 글은 ethernaut의 magicnumber의 저자가 작성한 글이며 bytecode와 opcode의 기본기에 대해서 다룬다. 나는 ethernaut 문제풀면서 이 개념에 접근하게 되었으며 공부하게 되었다. 글에는 내가 생각하는 부분이 포함되어있을 수도 있기 때문에, 내 글이 이해가 잘 되지 않는다면 원문을 읽어보는 것을 추천한다. 이미지 같은 경우 내가 공부하면서 얻은 최신이미지로 대체하였다. 시작 smart contract에 대해서 깊게 공부하면 할 수록 , ,  등과 같은 용어를 사용하게 될 것이다. 이러한 용어들은 무엇이고 우리는 그 용어들에 대해 알아야할까? 이러한 용어를 알기 위해서는 이더리움 가상 머신(EVM)에 더 깊이 배워야 한다. 나는 이 주제에 대해 구글에 검색해 보았지만 관련 자료가 너무 적어 놀랐다. 아마 너 기술적 이어서일까? 그래서 …","frontmatter":{"categories":"EVM","title":"Solidity Bytecode and Opcode Basics","date":"January 27, 2022"},"fields":{"slug":"/EVM/SolidityBytecodeandOpcodeBasics/"}}},{"node":{"id":"1886656e-9cee-5a14-8736-0dfa0dfc07b3","excerpt":"👋 1. Recovery Difficulty 6/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 잃어버린 CA의 주소를 찾고 CA가 가지고 있는 Ether 전부 회수하기 코드 분석 이미 잘 설명되어있어 간단한 분석만 주석에 적었다! 풀이 이 문제에서 우리의 목표는 잃어버린 CA의 주소를 찾고 CA안에 있는 Ether를 회수하는 것이다.\r\n설명을 읽어보면 Recovery contract를 이용해 SimpleToken contract의 instance를 만들었다. 하지만 instance의 주소는 저장되지 않았고 잃어버리게 되었다고 한다. 그리고 잃어버리기 전에 0.5 Ether를 보냈다고 한다. 그렇다면 우리는 어떻게하면 찾을 수 있을까? 주소를 찾는 방법은 2가지가 존재한다. Etherscan을 통해 확인하는 방법 nonce와 생성자 주소를 사용해 확인하는 방법 필자는 Etherscan을 사용하는 방법으로 문제를 풀었다. 1. Etherscan 사용하여 풀기 우리…","frontmatter":{"categories":"취약점분석","title":"(Ethernaut 취약점 17) Recovery","date":"January 25, 2022"},"fields":{"slug":"/ethernaut/17_recovery_ethernaut/17_recovery_ethernaut/"}}},{"node":{"id":"c77d2301-622d-52f0-95f4-de829869c733","excerpt":"👋 Bored Ape Yacht Club - Contract Review a b a b","frontmatter":{"categories":"ethereum","title":"Bored Ape Yacht Club - Contract Review (Writing)","date":"January 24, 2022"},"fields":{"slug":"/code_review/BoredApeYachtClub_codeReview/BoredApeYachtClub_codeReview/"}}},{"node":{"id":"d8d59912-8875-5219-91fe-88c7c14e7c5f","excerpt":"👋 1. Preservation Difficulty 8/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 instance의 ownership을 가져오면 승리한다. 코드 분석 이미 잘 설명되어있어 간단한 분석만 주석에 적었다! 풀이 이 문제에서 우리의 목표는 ownership을 가져오는 것이다. 여기서 우리가 꼭 알아야하는 개념은 delegate call이다. 나도 delegate call에 대해서 2번이나 다뤘지만 이 문제를 풀기 전까지 모호했던 것 같다.\r\n이 문제를 완벽하게 이해할 수 있다면 delegate call에 대해서 좀 더 확신을 가질 수 있을 것이다. Delegate Call은 무엇인가? Delegate Call 취약점 Delegation ethernaut 문제 6 위 링크에서 delegate call에 대한 개념을 복습해보자! 구글에 좋은 자료도 많아요ㅎㅎ Delegate call은 call과 비슷하지만 다른 2가지 특징을 더 가지고 있다. 호출한…","frontmatter":{"categories":"취약점분석","title":"(Ethernaut 취약점 16) Preservation","date":"January 24, 2022"},"fields":{"slug":"/ethernaut/16_preservation_ethernaut/16_preservation_ethernaut/"}}},{"node":{"id":"a50195a3-5268-5cec-aaef-a2d1dc8802ae","excerpt":"👋 Privacy Difficulty 5/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 내가 가지고 있는 Naught Coin의 잔액을 0으로 만들기 코드 분석 분석은 주석에!\r\n주석중 영어로 쓰여있는 것은 기존 코드에 포함되어있던 것이다:)!\r\n더 자세한 설명은 코드 뒤에 나온다. 풀이 NaughtCoin은 ERC20 토큰이며 당신은 이미 모든 토큰을 보유하고 있습니다. 중요한 건 10년의 폐쇄 기간이 지나야만 양도할 수 있다는 겁니다. 어떻게 하면 자유롭게 보낼 수 있는지 알아봐 주실 수 있나요? 토큰 잔액을 0으로 설정하여 이 수준을 완료하십시오. 이 문제에서 우리의 목표는 우리가 가지고 있는 token의 개수를 0으로 만드는 것이다. 하지만 위 코드를 보면 알 수 있다시피 transfer은 10년간 사용할 수 없다. 그렇다면 어떻게 풀어야 할까? ERC20 token을 deploy 해봤다면 transfer이외에 토큰을 주고받을 수 있는 방법이 있다는 것…","frontmatter":{"categories":"취약점분석","title":"(Ethernaut 취약점 15) Naught Coin","date":"January 22, 2022"},"fields":{"slug":"/ethernaut/15_naughtCoin_ethernaut/15_naughtCoin_ethernaut/"}}},{"node":{"id":"aab9bb19-ec57-5f39-a922-793ce1152c07","excerpt":"👋 Privacy Difficulty 6/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 Gatekeeper을 지나 entrant로 등록하기 GatekeeperOne과 같다. 코드 분석 분석은 주석에!\r\n더 자세한 설명은 코드 뒤에 나온다. 풀이 이 문제에서 우리의 목표는 etrant 를 얻는 것이다. 시작하기 전 Ethernaut에서 주는 힌트를 보고가자 첫번째 gate는 gatekeeperOne과 같다. gatekeeperOne의 gateOne을 기억해보자  키워드는 Solidity의 vanilla Solidity에 있지않은 기능등에 접근할 수 있게 해준다. 는 주어진 주소의 contract의 크기를 가져온다. 이더리움 Yellow Paper 7번 섹션에서 더 자세히 배울 수 있다. 는 bitwise operation이며 XOR을 뜻한다. Coin Flip을 참조하며 이번 레벨을 시작해도 좋을 것이다. 우리는 entrant를 얻기 위해 3개의 modifier…","frontmatter":{"categories":"취약점분석","title":"(Ethernaut 취약점 14) GatekeeperTwo","date":"January 21, 2022"},"fields":{"slug":"/ethernaut/14_gatekeeperTwo_ethernaut/14_gatekeeperTwo_ethernaut/"}}},{"node":{"id":"b50da4de-d0d0-5747-968e-d0d20046f3b3","excerpt":"👋 Gatekeeper One Difficulty 5/10 GatekeeperOne - 1에서 이어지는 글이다 ! 코드 분석 GatekeeperOne contract에서스 3개의 gate가 존재한다. gate는 모두 modifier로 되어있다. 즉 3개의 modifier의 조건을 만족시키면 된다. 분석은 주석에! 풀이 우리가 풀어야할 문제는 gate3 밖에 남지 않았다! Gate3는 Type Conversion를 잘 알아야 풀 수 있다. 3가지 조건에 만족해야하기 때문에 하나하나 확인해 보자! 이제 첫번째 조건을 보자. 첫번째 조건은 다음과 같다. 0x2da9a6f65FD24799 uint32 = bytes4 uint16 = bytes2 우선 bytes8 를 bytes2로 바꾸면 아래 4자리만 보존된다.\r\n그리고 bytes8 를 bytes4로 바꾸면 아래 8자리만 보존된다. bytes2와 bytes4가 같으려면 다음과 같이 bytes4에 0000이 붙어있으면 된다. 0x1234 =…","frontmatter":{"categories":"취약점분석","title":"(Ethernaut 취약점 13) Gatekeeper One - 2","date":"January 19, 2022"},"fields":{"slug":"/ethernaut/13_gatekeeperOne_ethernaut/13_gatekepperOne_2_ethernaut/"}}},{"node":{"id":"344111be-9d67-5007-8c4f-5ef106e780ac","excerpt":"👋 Gatekeeper One Difficulty 5/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 이번 포스트는 특별하게 2편으로 나누어 진행한다.\r\n이번편은 gate1과 gate2를 다룰 예정이다. 승리 조건 Gatekeeper을 지나 entrant로 등록하기 코드 분석 GatekeeperOne contract에서스 3개의 gate가 존재한다. gate는 모두 modifier로 되어있다. 즉 3개의 modifier의 조건을 만족시키면 된다. 분석은 주석에! 풀이 이 문제에서 우리의 목표는 3개의 gate를 무사히 지나 entrant로 등록하는 것이다. 우선 gate1은 이전에 풀었던 Telephone과 유사했다. 아래의 조건은 우리가 가지고 그냥 내가 직접 transaction을 보내지 않고 다른 contract를 만들어 사용하면 된다. gate1은 쉽게 풀렸다. 그렇다면 gate2번은 어떻게 pass할 수 있을까? 아래의 코드에서 중요한 점은 gasleft이다. g…","frontmatter":{"categories":"취약점분석","title":"(Ethernaut 취약점 13) Gatekeeper One - 1","date":"January 17, 2022"},"fields":{"slug":"/ethernaut/13_gatekeeperOne_ethernaut/13_gatekepperOne_1_ethernaut/"}}},{"node":{"id":"c6c29b2f-064c-5a3b-8233-859433a422f3","excerpt":"👋 Elevator Difficulty 4/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 elevator가 top에 갈수 있게 만드는 것이다. 즉 top 변수를 true로 만들면 된다. 코드 분석 분석은 주석에! 이번 문제는 굉장히 이해하기 어려웠다. 아무리 봐도 문제 자체를 이해할 수 가 없어서 12번 Privacy를 먼저 풀었다ㅋㅋ 풀이를 위한 Setup RemixIDE를 사용한다.\r\nremix 사용법은 YouTube와 google에 많이 나와있으니 최신것으로 찾아보자!\r\n그리고 docs를 읽어본다면 사용법을 쉽게 익힐 수 있을 것이다. 한 가지 주의할 점은 Instance는 remix에서 바로 deploy하는 것이 아니라 ethernaut에서 만든 instance의 주소를 가지고 addressAt을 누르면 된다.\r\n또한 우리는 Rinkeby Network를 사용하고 있으니 ENVIRONMENT를 “Injected Web3”를 선택해주어야 한다. 풀이 이 …","frontmatter":{"categories":"취약점분석","title":"(Ethernaut 취약점 11) Elevator","date":"January 15, 2022"},"fields":{"slug":"/ethernaut/11_elevator_ethernaut/11_elevator_ethernaut/"}}},{"node":{"id":"212bbcd2-dbe0-5ff5-bac8-3e44c8ba8474","excerpt":"👋 Privacy Difficulty 8/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 contract를 unlock 하기! 즉 변수 locked를 false로 만들기 코드 분석 분석은 주석에! 풀이 이 문제에서 우리의 목표는 Privacy contract를 locked 변수를 false로 만드는 것이다. Ethernaut 8 Vault와 비슷하다고 생각한다. 이 문제를 풀기전에 우리가 알아야 하는 것들이 있다. Storage casting 에 대해서 확실하게 알아야 한다.\r\nVault에서도 설명했지만 한번 더 storage에 대해서 설명하겠다.\r\nEVM의 Storage는 2^256개의 메모리 슬롯을 가지고 있다. 그리고 각 slot은 32 bytes( = 256 bits)의 크기이다. 하나의 slot에 여러가지 변수를 저정할 수 있다. 하지만 변수 선언 순서에 따라 slot 할당이 달라지니 유의하자! 아래의 예시처럼 uint8, uint256, uint8은 …","frontmatter":{"categories":"취약점분석","title":"(Ethernaut 취약점 12) Privacy","date":"January 14, 2022"},"fields":{"slug":"/ethernaut/12_privacy_ethernaut/12_privacy_ethernaut/"}}},{"node":{"id":"9aa33b93-be4d-59a4-9622-7ef29b9cf013","excerpt":"👋 Re-entrancy Difficulty 6/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 Reentrance contract의 모든 Ether 훔쳐오기 코드 분석 분석은 주석에! 풀이를 위한 Setup RemixIDE를 사용한다.\r\nremix 사용법은 YouTube와 google에 많이 나와있으니 최신것으로 찾아보자!\r\n그리고 docs를 읽어본다면 사용법을 쉽게 익힐 수 있을 것이다. 한 가지 주의할 점은 Reentrance는 remix에서 바로 deploy하는 것이 아니라 ethernauts에서 만든 instance의 주소를 가지고 addressAt을 누르면 된다.\r\n또한 우리는 Rinkeby Network를 사용하고 있으니 ENVIRONMENT를 “Injected Web3”를 선택해주어야 한다. 풀이 이 문제에서 우리의 목표는 Reentrance contract에서 모든 Ether를 훔쳐오는 것이다. 위 코드는 취약점 시리즈 1에서 공부했었던 Reen…","frontmatter":{"categories":"취약점분석","title":"(Ethernaut 취약점 10) Re-entrancy","date":"January 13, 2022"},"fields":{"slug":"/ethernaut/10_Re-entrancy_ethernaut/10_Re-entrancy_ethernaut/"}}},{"node":{"id":"336ab30f-c6c7-59ec-b5c1-9a35af199f03","excerpt":"👋 King Difficulty 6/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 게임을 break 하기 즉 내가 왕이되고 누구도 왕이 될 수 없게 만들기 코드 분석 분석은 주석에! 풀이를 위한 Setup RemixIDE를 사용한다.\r\nremix 사용법은 YouTube와 google에 많이 나와있으니 최신것으로 찾아보자!\r\n그리고 docs를 읽어본다면 사용법을 쉽게 익힐 수 있을 것이다. 한 가지 주의할 점은 King은 remix에서 바로 deploy하는 것이 아니라 ethernauts에서 만든 instance의 주소를 가지고 addressAt을 누르면 된다.\r\n또한 우리는 Rinkeby Network를 사용하고 있으니 ENVIRONMENT를 “Injected Web3”를 선택해주어야 한다. 풀이 이 문제에서 우리의 목표는 이 게임을 break하는 것이다. 즉 누구도 게임을 할 수 없게 만들면 된다. 위 코드는 내가 전에 공부했던 King of Ether이라는…","frontmatter":{"categories":"취약점분석","title":"(Ethernaut 취약점 9) King","date":"January 13, 2022"},"fields":{"slug":"/ethernaut/9_king_ethernaut/9_king_ethernaut/"}}},{"node":{"id":"dbf32f1a-387d-5ff1-922e-5818adc1df36","excerpt":"👋 Vault Difficulty 3/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 vault를 unlock하면 승리한다. locked 변수를 false로 만들기 코드 분석 분석은 주석에! 풀이 이 문제에서 우리의 목표는 vault를 unlock하는 것이다. 위에 코드에서 보다싶이 우리는 올바른 비밀 번호를 가지고 unlock()을 실행시키면 vault를 unlock 할 수 있다는 것을 알 수 있다. 여기서 유심히 봐야할 점은 password가 smart contract에 저장되어 있다는 점이다. 블록체인 특성상 private으로 정의되었어도 외부에서 정보를 확인할 수 있다. Privacy 관련 취약점을 확인해 보자! 모든 코드는 console창에서 이루어진다.\r\nctrl + shift + i를 눌러 console창을 활성화 시키자 Submit instance를 누르고 조금 기다리면 block이 mine되고, 아래와 같이 뜨며 마무리된다. 마무리 이 문제를 완…","frontmatter":{"categories":"취약점분석","title":"(Ethernaut 취약점 8) Vault","date":"January 10, 2022"},"fields":{"slug":"/ethernaut/8_vault_ethernaut/8_vault_ethernaut/"}}},{"node":{"id":"33162f8d-5604-5b8d-9f14-5ad2b13b6267","excerpt":"👋 Private 들어가기전 여기서 말하는 Private이란 무엇인가? 여기서 말하는 private은 private variable 을 말한다. 즉 variable의 visability가 private이라는 뜻이다. 예시로   등이 될 수 있다. 왜 문제가 되는가? private은 smart contract 범위에 대해서만 비공개이다. 즉 다른 smart contract에서 엑세스하거나 수정할 수 없다. 하지만 이더리움 블록체인상의 데이터는 누구나 읽을 수 있음으로 정말 private한 데이터는 저장해서는 안된다.\r\nprivate variable 취약점에 관한 글은 여기서 볼 수 있다. private 예제를 이해하기 위해 알아야 하는 것 smart contract의 storage: 각 smart contract는 2^256 slots를 가진다. slot은 각각 32 bytes를 저장할 수 있다 데이터는 선언 순서에 따라 앞에서부터 순차적으로 저장된다. 공간 절약을 위해 최적화된다.…","frontmatter":{"categories":"취약점분석","title":"(취약점 시리즈 10) Private","date":"January 10, 2022"},"fields":{"slug":"/vulnerability/private_variable/private_variable/"}}},{"node":{"id":"58c26981-b970-5d1c-9690-29b338277f90","excerpt":"👋 Force Difficulty 5/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 Force contract의 balance를 0보다 크게 만든다면 승리한다. 코드 분석 분석은 주석에! 풀이를 위한 Setup RemixIDE를 사용한다.\r\nremix 사용법은 YouTube와 google에 많이 나와있으니 최신것으로 찾아보자!\r\n그리고 docs를 읽어본다면 사용법을 쉽게 익힐 수 있을 것이다. 한 가지 주의할 점은 Force는 remix에서 바로 deploy하는 것이 아니라 ethernauts에서 만든 instance의 주소를 가지고 addressAt을 누르면 된다.\r\n또한 우리는 Rinkeby Network를 사용하고 있으니 ENVIRONMENT를 “Injected Web3”를 선택해주어야 한다. 풀이 이 문제에서 우리의 목표는 Force contract의 balance를 0을 초과하게 만드는 것이다. 코드가 없는데 어떻게 Ether를 보내라는 것인가 싶었다…","frontmatter":{"categories":"취약점분석","title":"(Ethernaut 취약점 7) Force","date":"January 09, 2022"},"fields":{"slug":"/ethernaut/7_force_ethernaut/7_force_ethernaut/"}}},{"node":{"id":"83a42543-4d2b-5084-8bce-93f63f12c217","excerpt":"👋 Self Destruct 들어가기전 Self Destruct란 무엇인가? self destruct는 contract를 삭제할 수 있는 유일한 수단이다. contract안에 남아있는 Ether를 address에게 반환한다. selfdestruct를 실행시키면 anAddress에게 contract에 남아있는 Ether이 반환된다. 만약에 반환하는 address는 EOA와 CA 모두 넣을 수 있다. 하지만 반환한 CA가 payable이 아니라면 반환된 Ether은 다시는 찾을 수 없게된다. 즉 반환된 CA에 영원히 LOCK 된다. 보다 잘 이해하기 위해 Example Code를 살펴보자!! Example code 간단한 code로 이해해보자! 이 contract는 7번째로 deposit()하여 7 Ether를 가져갈 수 있는 게임이다.\r\ndeposit()을 call할 때 msg.value는 1 Ether만 설정할 수 있다. 시나리오는 이렇다. EtherGame contract가 배포…","frontmatter":{"categories":"취약점분석","title":"(취약점 시리즈 9) Self Destruct","date":"January 09, 2022"},"fields":{"slug":"/vulnerability/selfdestruct/selfdestruct/"}}},{"node":{"id":"275a87c2-02fe-592b-9abe-f3da73276d8a","excerpt":"👋 1. Delegation Difficulty 4/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 instance의 ownership을 가져오면 승리한다. 코드 분석 분석은 주석에! 풀이 이 문제에서 우리의 목표는 ownership을 가져오는 것이다. 만약 우리가 가지고 있다면 우선 여기서 말해주는 힌트를 보자! delegatecall Fallback function method id 를 알면 도움이 될 것이라고 말한다. Delegate Call delegate call은 일전에 내가 취약점 시리즈에서 다룬 적 있다! solidity official docs와 내 글을 보면 이해가 될 것이다.\r\nDelegateCall <= Click\r\nSolidity Docs <= Click fallback Fallback 함수는 contract에서 함수를 실행시킬때 함수가 존재하지 않는다면 실행되는 function이다. method id This is derived as t…","frontmatter":{"categories":"취약점분석","title":"(Ethernaut 취약점 6) Delegation","date":"January 09, 2022"},"fields":{"slug":"/ethernaut/6_delegation_ethernaut/6_delegation_ethernaut/"}}},{"node":{"id":"a1fe8ee0-2157-5d19-bdf1-cbe8db94070d","excerpt":"👋 1. Token Difficulty 3/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 additional token 가져오기(해킹해서 가져오기) 코드 분석 분석은 주석에! 풀이를 위한 Setup RemixIDE를 사용한다.\r\nremix 사용법은 YouTube와 google에 많이 나와있으니 최신것으로 찾아보자!\r\n그리고 docs를 읽어본다면 사용법을 쉽게 익힐 수 있을 것이다. 한 가지 주의할 점은 Token은 remix에서 바로 deploy하는 것이 아니라 ethernauts에서 만든 instance의 주소를 가지고 addressAt을 누르면 된다.\r\n또한 우리는 Rinkeby Network를 사용하고 있으니 ENVIRONMENT를 “Injected Web3”를 선택해주어야 한다. 풀이 이 문제에서 우리는 기본적으로 주어진 20 토큰 이외에 추가적인 토큰을 얻으면 승리한다. 가장 먼저 우리는 코드에 허점을 찾아야 한다. 하지만 지금까지와 문제와 다르게 그…","frontmatter":{"categories":"취약점분석","title":"(Ethernaut 취약점 5) Token","date":"January 08, 2022"},"fields":{"slug":"/ethernaut/5_token_ethernaut/5_token_ethernaut/"}}},{"node":{"id":"3ae8acb4-3f11-5baa-9c6f-fb0b7b1620df","excerpt":"👋 1. Telephone Difficulty 1/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 Ownership 뺐어오기 코드 분석 분석은 주석에! 풀이를 위한 Setup RemixIDE를 사용한다.\r\nremix 사용법은 YouTube와 google에 많이 나와있으니 최신것으로 찾아보자!\r\n그리고 docs를 읽어본다면 사용법을 쉽게 익힐 수 있을 것이다. 한 가지 주의할 점은 CoinFlip은 remix에서 바로 deploy하는 것이 아니라 ethernauts에서 만든 instance의 주소를 가지고 addressAt을 누르면 된다.\r\n또한 우리는 Rinkeby Network를 사용하고 있으니 ENVIRONMENT를 “Injected Web3”를 선택해주어야 한다. 풀이 이 문제에서 우리는 ownership을 뺐어와야 한다. 그리고 우리는 코드분석에서 봤듯이 ownership을 가져올 수 있는 방법은 changeOwner()를 call하여 조건을 만족시키면 …","frontmatter":{"categories":"취약점분석","title":"(Ethernaut 취약점 4) Telephone","date":"January 07, 2022"},"fields":{"slug":"/ethernaut/4_telephone_ethernaut/4_telephone_ethernaut/"}}},{"node":{"id":"75b5c2d9-4932-58ad-9801-02a072fd28cb","excerpt":"👋 1. CoinFlip Difficulty 3/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 동전 뒤집기 게임에서 10번 연속 예측 성공하기 코드 분석 분석은 주석에! 풀이를 위한 Setup RemixIDE를 사용한다.\r\nremix 사용법은 YouTube와 google에 많이 나와있으니 최신것으로 찾아보자!\r\n그리고 docs를 읽어본다면 사용법을 쉽게 익힐 수 있을 것이다. 한 가지 주의할 점은 CoinFlip은 remix에서 바로 deploy하는 것이 아니라 ethernauts에서 만든 instance의 주소를 가지고 addressAt을 누르면 된다.\r\n또한 우리는 Rinkeby Network를 사용하고 있으니 ENVIRONMENT를 “Injected Web3”를 선택해주어야 한다. 풀이 이 문제는 random으로 생성되는 값을 연속해서 맞추는 것이다.\r\n그리고 이 문제에서 주목해야 할 점은 randomness이다. solidity를 사용하여 randomn…","frontmatter":{"categories":"취약점분석","title":"(Ethernaut 취약점 3) CoinFlip","date":"January 06, 2022"},"fields":{"slug":"/ethernaut/3_coinFilp_ethernaut/3_coinFlip_ethernaut/"}}},{"node":{"id":"b07cd563-6b17-5ce7-b7b0-e27977da9b90","excerpt":"👋 tx.origin txorigin vs msg.sender 주로 tx.origin은 msg.sender과 비교된다. 우선 우리가 잘 아는 msg.sender는 함수를 호출한 사람을 가리키는 주소이다.\r\ntx.origin을 보면 tx는 transaction을 뜻한다. 즉 transaction을 만든 address를 뜻한다. 만약 account에서 smart contract A로 transaction을 보낸다면 msg.sender와 tx.origin은 같을 것이다. 왜냐하면 transaction을 만든이와 transaction을 보낸 사람이 같기 때문이다. 그렇다면 account -> smart contract A -> smart contract B 순으로 transaction을 보낸다면 어떻게 될까? B의 관점에서 본다면 transaction을 만든이는 account이고 msg.sender은 A일 것이다.\r\n밑에 사진을 본다면 이해가 더 쉬울 것이다.\r\n Example Code …","frontmatter":{"categories":"취약점분석","title":"(취약점 시리즈 8) tx.origin","date":"January 03, 2022"},"fields":{"slug":"/vulnerability/tx.origin/tx_origin/"}}},{"node":{"id":"9c0241f5-49d5-5014-8924-fca54d0e570d","excerpt":"👋 1. Fallout Difficulty 2/10 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 contract의 ownership을 뺐어오기 코드 분석 사실 fallout에서는 코드를 분석 할 필요가 없다.\r\n한번 코드를 읽어보고 밑으로!! 풀이 우리의 문제는 “contract의 ownership을 뺐어오기” 이다. Contract를 자세히 보면 constructor에 오타가 있는 것으로 보인다.\r\n그렇게되면 우리는 Fal1out()을 call함으로써 ownership을 가져올 수 있다 모든 코드는 console창에서 이루어진다.\r\nctrl + shift + i를 눌러 console창을 활성화 시키자 완료 후 Submit instance를 누르고 조금 기다리면 block이 mine되고, 부가설명 원래 constructor는 아래와 같이 contract의 이름과 동일하게 사용했다. 하지만 Solidity v0.5.0에서 constructor는 ‘constructo…","frontmatter":{"categories":"취약점분석","title":"(Ethernaut 취약점 2) Fallout","date":"January 02, 2022"},"fields":{"slug":"/ethernaut/2_fallout_ethernaut/2_fallout_ethernaut/"}}},{"node":{"id":"aa96c6ad-2cfb-55c0-b0df-585740dd9f33","excerpt":"👋 1. Fallback Difficulty 1/10 직접 푼 Ethernauts 풀이를 적어보려고 한다. 취약점에 공부했던 취약점을 실제로 공격해보며 복습 및 실습을 해볼수 있어 좋은 것 같다. 승리 조건 코드 분석 풀이 순서로 진행 될 것이다. 승리 조건 contract의 ownership을 뺐어오기 contract의 balance를 0으로 만들기 코드 분석 분석은 주석에! 풀이 우리는 2가지의 문제를 풀어야 한다. contract의 ownership을 뺐어오기 contract의 balance를 0으로 만들기 차례차례 풀어보겠다.\r\n코드를 봤을 떄 contract의 ownership을 가져올 수 있는 방법은 2가지가 있다. contribute() receive() contribute()를 이용해 owner가 되려면 초기 owner의 contributions 1000 ether보다 더 큰 돈을 contract로 보내야 한다. 하지만 contribute()의 require을 보면 …","frontmatter":{"categories":"취약점분석","title":"(Ethernaut 취약점 1) Fallback","date":"January 02, 2022"},"fields":{"slug":"/ethernaut/1_fallback_ethernaut/1_fallback_ethernaut/"}}},{"node":{"id":"e0e97a21-8a72-5a35-9c3f-9a61ee547457","excerpt":"👋 DoS(Denial of Service) With Block Gas Limit 들어가기전 GAS란 무엇인가? 이더리움 블록체인의 블록들은 각 블록마다 소비 할 수 있는 가스의 최대량이 정해져있다. 즉 각 블록이 소비할 수 있는 최대량을 넘어선다면 transaction들은 fail 하게된다. DoS With Block Gas Limit 연산당 Gas가 정해져 있으며 smart contract를 실행할 때 계산된다. Block Gas Limit DOS은 smart contract가 실행되고 Gas를 계산할때 최대 연산량을 초과하면 발생한다.\r\n예를 들어보겠다. 한 smart contract에 사용자가 많아짐에 따라 크기가 증가하는 Array가 있다. smart contract안에는 그 array 전체를 순환하는 작업이 있다. 처음에는 괜찮았으나 시간이 지날수록 Array가 커져 연상량이 증가한다. 연산량이 너무 많아져 Denial Of Service로 이어질 수 있다. 보다 잘 이…","frontmatter":{"categories":"취약점분석","title":"(취약점 시리즈 7) DOS With Block Gas Limit","date":"December 31, 2021"},"fields":{"slug":"/vulnerability/dos_with_block_gas_limit/dos_block_gas_limit/"}}},{"node":{"id":"74712f9f-52f3-558c-ab49-7b3557819053","excerpt":"👋 Unexpected Revert Unexpected Revert란? Unexpected Revert는 이름에서 알 수 있듯이, 트랜잭션을 고의적 revert시킴으로써 스마트 계약이 작동되지 않는 상태로 만드는 취약성입니다. Example code 출처: https://solidity-by-example.org/hacks/denial-of-service/ 시나리오는 이렇다. KingOfEther of Ether Contract가 배포된다. 처음으로 A가 1 Ether를 claimThrone()에 보냄으로써 King이 된다. 다음으로 B가 2 Ether를 claimThrone()에 보냄으로써 B가 King으로 바뀐다. King이 바뀌기 전에 A에게 1 Ether를 refund 해준다. C가 KingOfEther의 주소와 함께 Attack contract를 배포한다. C는 Attack.attack을 3 Ether와 함꼐 호출한다. C는 C는 king이 되고 Attack contrac…","frontmatter":{"categories":"취약점분석","title":"(취약점 시리즈 6) DOS With Unexpected Revert","date":"December 29, 2021"},"fields":{"slug":"/vulnerability/dos_with_unexpected_revert/dos_unexpected_revert/"}}},{"node":{"id":"b5bcc145-ea08-5f50-b709-61d75f38540e","excerpt":"👋 Front Running Front Running이란? transaction이 포함된 block이 생성되기까지 약간의 시간이 소요된다. 네트워크 참여자들(miners & full nodes)은 처리되기 전의 transcation을 볼 수 있다. 만약 네트워크 참여자가 악의적인 마음을 품는다면 이후에 일어날 transcation을 알 수 있고 이에 대한 정보를 악의적으로 사용할 수 있다. 즉 front running은 block이 채굴되기 전 transcation을 확인해 자신이 더 높은 값의 gas price를 지불하여 이득을 취하는 것이다. 예시를 본다면 더 이해가 잘 될 것이다. Example Code 이 코드는 간단한 추측 게임 코드이다.\r\nhash 값의 변환 전 단어 맞출시 10 ether를 contract에 있는 10 ether를 가져갈 수 있다. 시나리오는 이렇다. A가 FindThisHash contract를 10 ether를 포함해 배포한다. B가 hash의 변환…","frontmatter":{"categories":"취약점분석","title":"(취약점 시리즈 5) Front Running","date":"December 27, 2021"},"fields":{"slug":"/vulnerability/front_running/front_running/"}}},{"node":{"id":"4ce78d24-2527-55dd-87de-8312b5de194b","excerpt":"👋 DelegateCall 들어가기전 Call 과 Delegate Call의 차이점 Call이란? Call은 다른 contract와 상호작용하기 위한 low level function이다. 컨트랙트 A를 통해 컨트랙트 B의 함수 호출시 B의 Storage를 변경시키며 msg.sender(호출자)는 컨트랙트A의 주소가 됩니다. Delegate Call이란? delegate call은 call과 매우 유사하다. delegate은 ‘위임하다’ 라는 뜻으로 call에 대한 권한을 위임한다고 볼 수 있다. Delegate Call에는 2가지 특징이 있다. 호출한 contract의 context를 기반으로 동작된다. storage layout은 delegatecall을 이용하는 contract와 같아야한다. 예를 들어 컨트랙트 A를 통해 컨트랙트 B 호출시 B의 Storage를 변경시키지 않고, B의 코드를 A에서 실행합니다. msg.sender와 msg.value가 컨트랙트 A 호출시와 같…","frontmatter":{"categories":"취약점분석","title":"(취약점 시리즈 4) Delegate Call","date":"December 26, 2021"},"fields":{"slug":"/vulnerability/delegate_call/delegate_call/"}}},{"node":{"id":"61d64787-9a91-539d-8e79-abcc19096677","excerpt":"👋 block.timestamp block.timestamp란? block.timestamp는 msg.sender처럼 블록체인에서 제공해주는 global 변수 중 하나이다. 이는 블록 생성 시간을 나타낸다.\r\n블록체인의 timestamp는 생성 시점에 데이터가 존재했다는 사실을 증명해주기 때문에 블록체인 자체에 매우 중요하다. 왜 취약점 시리즈에 들어갔을까? 바로 block.timestamp는 채굴자(miner)들에게 영향을 받을 수 있기 때문이다. 즉 block.timestamp를 통해 random을 생성하거나 block.timestamp와 관련해서 접근할 수 있는 함수가 있다면 smart contract에게 좋지 않은 영향을 끼칠 수 있다. Example code 출처: https://solidity-by-example.org/hacks/block-timestamp-manipulation/ 위 코드를 실행시켜 볼 수는 있지만 실제 해킹 실습까지 해보는 것은 어려울 것이라고 생각…","frontmatter":{"categories":"취약점분석","title":"(취약점 시리즈 3) block.timestamp","date":"December 22, 2021"},"fields":{"slug":"/vulnerability/block_timestamp/block_timestamp/"}}},{"node":{"id":"957cc097-e5ab-5c01-a410-7e2216f8f744","excerpt":"👋 Over & UnderFlow 들어가기 전 Overflow와 Underflow는 solidity 0.8.0 버전부터 알아서 컨트롤 되게 바뀌었다.\r\n0.8.0 이후 버전을 사용하시는 분은 아래로 내려가도 좋다. OverFlow와 UnderFlow란 Overflow는 지정된 정수형(int)의 최댓값보다 커졌을 때 발생한다. Underflow는 지정된 정수형(uint)의 최솟값보다 작아졌을 때 발생한다.\r\nSolidity에서는 unsigned Integer(uint)를 자주 사용한다. uint256을 기준으로 했을때 최대값은 2256-1이고 최소값은 0이다. 즉 2256-1에 1을 더했을때 Overflow 0에서 1을 뺐을때 underflow가 일어날 것이다. ExampleColde를 보면 보다 쉽게 이해 할 수 있을 것이다. Example Code remix IDE에서 실습을 진행한다면 이해가 더욱 빠를것이다! 출처: https://medium.com/loom-network-ko…","frontmatter":{"categories":"취약점분석","title":"(취약점 시리즈 2) Over & Under Flow?","date":"December 21, 2021"},"fields":{"slug":"/vulnerability/over_under_flow/over_under_flow/"}}},{"node":{"id":"5af0743e-deb7-5f3d-ae88-aa765fa5ca31","excerpt":"👋 Reentrancy Attack (재진입 공격) 들어가기전 Fallback 함수? Fallback 함수는 contract에서 함수를 실행시킬때 함수가 존재하지 않는다면 실행되는 function이다.\r\n0.6이전 버전에서는 fallback이 ether는 것과 존재하지 않는 함수의 대비책으로 사용되었지만 0.6 이후 버전부터 fallback은 fallback과 receive로 나누어졌다. 0.6부터는 fallback을 사용하지 않고 receive를 통해 이더를 받을 수 있다. Reentrancy Attack(재진입 공격)이란? Reentrancy Attack은 contract A가 하나의 user로써 contract B 에게 transaction을 보낸다. 이때 contract A가 요청에 대한 제어권을 가지게된다. 그렇게 되면 contract A가 보낸 첫번째 요청이 끝나기 전에 다른 함수를 계속해서 호출 할 수 있게된다. 이는 재진입을 ether를 빼올 수 있게 된다. Exam…","frontmatter":{"categories":"취약점분석","title":"(취약점 시리즈 1) Reentrancy Attack (재진입 공격)?","date":"December 20, 2021"},"fields":{"slug":"/vulnerability/reentrancy_attack/reentrancy_attack/"}}},{"node":{"id":"05a982f1-ea0e-5e09-b8af-8d5c46045698","excerpt":"👋 EVM(Ethereum Virtual Machine)? 그게 뭔데? solidity로 smart contract를 작성하면서 gas optimization 등에 대해 깊이 알기위해 EVM을 공부를 시작하였다! 1. Virtual Machine? 먼저 Virtual Machine(가상 머신)이란 뭘까? 가상머신이란 물리적으로 존재하는 컴퓨터는 아니지만 실제 컴퓨터처럼 작동하는 소프트웨어이다. 가상머신을 사용하게 되면 하나의 컴퓨터로 2가지 이상의 운영체제를 실행 할 수 있고, 상호간 충돌을 없앨 수 있다. 나는 우분투를 사용했었는데, 역시 사용하면서 배우는게 최고인 것 같다. 2. EVM(Ethereum Virtual Machine) 이더리움 노드들이 공유하는 하나의 가상 머신이다. 모두가 다 같이 사용하기에 “World Computer”이라고도 불린다. 그리고 스마트 컨트랙트의 배포와 실행을 처리하는 이더리움의 일부이다. EVM안에 배포된 코드는 다른 프로세스들과 완전히 격리되…","frontmatter":{"categories":"EVM","title":"EVM과 Transaction","date":"December 13, 2021"},"fields":{"slug":"/EVM/evm/"}}},{"node":{"id":"b1d8d626-9e8c-56e1-9d4c-bbd3bb5e03ea","excerpt":"👋 블로그를 시작한 이유? 1. 배운것에 대한 내용 정리 무언가를 배우고 글로 남기는 것이 굉장히 중요하다고 생각한다. 블로그를 통해 앞으로 배울 것 들에 대한 기록을 남기고 싶어 시작한다. 2. 내 생각 정리 & 글쓰는 법 내가 배운 것과 생각을 잘 정리해 글로 나타내고 전달하는 것은 어렵다. 블로그를 통해 의사소통 에 중요한 정확한 정보 정리 및 전달을 배우고 싶다. 앞으로 블로그에는 개발 관련 공부 자료 및 내가 했던 경험에 대해 정리해 업로드 할 예정이다. 1. 배운것에 대한 내용 정리 2. 내 생각 정리 & 글쓰는 법","frontmatter":{"categories":"~feature~","title":"블로그를 시작한 이유?","date":"December 07, 2021"},"fields":{"slug":"/startingBlog/"}}}]},"site":{"siteMetadata":{"language":"ko","author":{"name":"한성원","bio":{"role":"개발자","description":["새로운 것에 도전하는","능동적으로 일하는","배워서 남주는"],"thumbnail":"sample.png"},"social":{"github":"https://github.com/holyhansss","linkedIn":"","email":"holyhansss@gmail.com"}}}}},"pageContext":{}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437","3350743975"]}